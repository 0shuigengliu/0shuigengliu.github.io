<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【转载】正则表达式不会用？记不住？10分钟动手全部搞懂</title>
      <link href="/posts/442cf661.html"/>
      <url>/posts/442cf661.html</url>
      
        <content type="html"><![CDATA[<h2 id="文章出处"><a href="#文章出处" class="headerlink" title="文章出处"></a>文章出处</h2><p><a href="https://juejin.cn/user/3377313752032909/posts">是贝贝贝贝贝波a</a></p><h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><p>正则表达式对于我们来说既熟悉又陌生，我们在很多时候都遇到过，但是学起来又很难记，不好理解；在没有接触正则表达式的时候，我就在想这一串奇怪的字符为啥可以代替其他很长的一段代码就可以得到预期值，去网上找资料和技术文章学习的时候，发现有很多知识点晦涩难懂；下面我将用非常通俗易懂的方法和大家一起学习正则表达式。</p><blockquote><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p></blockquote><p>首先我们要在网页编译器 <a href="https://link.juejin.cn/?target=https://regex101.com/r/tG82ya/1/"><strong>regular expression 101</strong></a> 在线编译里自己动手跟着操作一遍就会发现其实没有那么难理解。（一定要实际动手操作加深记忆）</p><h2 id="一、基础字符"><a href="#一、基础字符" class="headerlink" title="一、基础字符"></a>一、基础字符</h2><p>接下来一起操作一遍：(默认选中颜色表示符合条件)</p><h3 id="1-号表示前边的字符必须至少出现一次（1次或多次）；"><a href="#1-号表示前边的字符必须至少出现一次（1次或多次）；" class="headerlink" title="1. +号表示前边的字符必须至少出现一次（1次或多次）；"></a>1.<code> +</code>号表示前边的字符必须至少出现一次（1次或多次）；</h3><img src="/posts/442cf661/1.webp" class=""><h3 id="2-表示前边的字符可以不出现，或者出现一次或者多次（0次、或1次、或多次）"><a href="#2-表示前边的字符可以不出现，或者出现一次或者多次（0次、或1次、或多次）" class="headerlink" title="2.* 表示前边的字符可以不出现，或者出现一次或者多次（0次、或1次、或多次）"></a>2.<code>*</code> 表示前边的字符可以不出现，或者出现一次或者多次（0次、或1次、或多次）</h3><img src="/posts/442cf661/2.webp" class=""><h3 id="3-号表示前面的字符最多只可以出现一次（0次或1次）"><a href="#3-号表示前面的字符最多只可以出现一次（0次或1次）" class="headerlink" title="3.?号表示前面的字符最多只可以出现一次（0次或1次）"></a>3.<code>?</code>号表示前面的字符最多只可以出现一次（0次或1次）</h3><img src="/posts/442cf661/3.webp" class=""><h3 id="4-号："><a href="#4-号：" class="headerlink" title="4.{}号："></a>4.<code>&#123;&#125;</code>号：</h3><p>还是上边的例子</p><p>比如希望<code>&#123;&#125;</code>前面的字符出现的次数是4次，就用<code>&#123;4&#125;</code>表示</p><img src="/posts/442cf661/4.webp" class=""><p><code>&#123;&#125;</code> 还可以允许我们输入一个范围；比如<code>&#123;2,4&#125;</code>表示前一个字符出现2到4次；</p><img src="/posts/442cf661/4-2.webp" class=""><p>如果想表示出现2次以上；就用<code>&#123;2，&#125;</code>表示；</p><img src="/posts/442cf661/4-3.webp" class=""><h3 id="5-如果想查找多个字符就"><a href="#5-如果想查找多个字符就" class="headerlink" title="5.如果想查找多个字符就()+"></a>5.如果想查找多个字符就<code>()+</code></h3><img src="/posts/442cf661/5.webp" class=""><h3 id="6-“或”-通配符-如果想找-a-dog和a-cat就在（）里加“-”；这里前面会先区匹配“a”"><a href="#6-“或”-通配符-如果想找-a-dog和a-cat就在（）里加“-”；这里前面会先区匹配“a”" class="headerlink" title="6.“或” 通配符 如果想找 a dog和a cat就在（）里加“|”；这里前面会先区匹配“a”"></a>6.<code>“或”</code> 通配符 如果想找 a dog和a cat就在<code>（）</code>里加<code>“|”</code>；这里前面会先区匹配<code>“a”</code></h3><img src="/posts/442cf661/6.webp" class=""><h3 id="7-字符类-可以匹配中括号里的字符，匹配到的字符只能取自于它们"><a href="#7-字符类-可以匹配中括号里的字符，匹配到的字符只能取自于它们" class="headerlink" title="7.字符类[]+可以匹配中括号里的字符，匹配到的字符只能取自于它们"></a>7.字符类<code>[]+</code>可以匹配中括号里的字符，匹配到的字符只能取自于它们</h3><img src="/posts/442cf661/7.webp" class=""><p>另外 <code>[]+ </code>可以匹配字符的范围</p><p><code>[a-z]+ </code>表示匹配所有的小写英文字母；<code>[A-Z]+</code> 表示匹配所有的大写英文字母;</p><p><code>[a-zA-Z]+</code> 表示匹配所有的英文字符；<code>[a-zA-Z0-9]+</code> 表示所有的英文字符和数字</p><h3 id="8-如果在-前边加-，就表示匹配除了尖号后边列出的【以外】的字符（包括换行符）"><a href="#8-如果在-前边加-，就表示匹配除了尖号后边列出的【以外】的字符（包括换行符）" class="headerlink" title="8.如果在 []+ 前边加 ^ ，就表示匹配除了尖号后边列出的【以外】的字符（包括换行符）"></a>8.如果在 <code>[]+</code> 前边加 <code>^</code> ，就表示匹配除了尖号后边列出的【<strong>以外</strong>】的字符（包括换行符）</h3><img src="/posts/442cf661/8.webp" class=""><h2 id="二、一系列常用的字符；"><a href="#二、一系列常用的字符；" class="headerlink" title="二、一系列常用的字符；"></a>二、一系列常用的字符；</h2><h3 id="1、一些元字符（Meta-characters）"><a href="#1、一些元字符（Meta-characters）" class="headerlink" title="1、一些元字符（Meta-characters）"></a>1、一些元字符（Meta-characters）</h3><p>比如数字、空白符、单词开头、结尾等等它们被称为元字符；</p><p><strong>\d \w \s \D \W \S … 正则表达式的大多数元字符都以反斜杠开头；</strong></p><p>1）<code>\d </code>是数字字符，等同于之前写的<code> [0-9]+</code>;</p><img src="/posts/442cf661/67037041c966be1dbb01d981177c4189_MD5.webp" class="" title="11.png"><p>2）<code>\w </code>代表单词字符（英文、数字及下划线）</p><img src="/posts/442cf661/18fbc146d3ea9d9c83c353d7673a6a75_MD5.webp" class="" title="12.png"><p>3）<code>\s</code> 代表空白符 （包含Tab和换行符）</p><img src="/posts/442cf661/c99b72aa59d119a247f2fa599dd63a11_MD5.webp" class="" title="13.png"><p>4）与 <code>\d </code>相对应的<code> \D</code> 代表非数字字符</p><img src="/posts/442cf661/eb4788cfcbfcf5d2c86088da26821644_MD5.webp" class="" title="14.png"><p>5） 与 <code>\w</code> 相对应的 <code>\W </code>代表非单词字符</p><img src="/posts/442cf661/c1b3f81d439ee8ca5385e1157c3dd8c8_MD5.webp" class="" title="15.png"><p>6） 与 <code>\s</code> 相对应的<code> \S</code> 代表非空白字符</p><img src="/posts/442cf661/4d80c2dc28c5319aa1047ce160522c3a_MD5.webp" class="" title="16.png"><p><strong>2. 其中<code> .</code> 在正则表达式中也是一个特殊字符；它代表任意字符，但不包含换行字符。</strong></p><img src="/posts/442cf661/9a8cd050497e1c4b13b17f4514027812_MD5.webp" class="" title="17.png"><p><strong>3.两个特殊字符 <code>^</code> 匹配行首、<code>$</code> 匹配行尾；</strong></p><img src="/posts/442cf661/b69ebfe7a2a1b48d49f5dec04c404dd0_MD5.webp" class="" title="18.png"><img src="/posts/442cf661/3b387a54c519a5033a72d6fa97fdb9fc_MD5.webp" class="" title="19.png"><h2 id="三、一些高级概念"><a href="#三、一些高级概念" class="headerlink" title="三、一些高级概念"></a>三、一些高级概念</h2><h3 id="1、贪婪与懒惰匹配"><a href="#1、贪婪与懒惰匹配" class="headerlink" title="1、贪婪与懒惰匹配"></a>1、贪婪与懒惰匹配</h3><p>之前学到 <code>* + &#123;&#125; </code>在匹配字符串的时候默认会去匹配尽可能多的字符</p><p>比如我们需要匹配下边的html标签；我们 最开始想到的肯定是 <code>&lt;.+&gt;</code>来匹配；</p><img src="/posts/442cf661/f8bca230e5bfd4bbf300c72200f481b6_MD5.webp" class="" title="20.png"><p>但是这么会把全部字符和标签选中，因为 <code>.</code> 表示任意字符，<code>+</code> 号又表示前一项可以出现多次；不是我们想要的标签匹配，那么我们该怎么办呢？其实只需要在<code>+</code>号右边加一个 <code>？</code>就好了。</p><p>它会将正则表达式中默认的贪婪匹配（Greedy Math）切换为懒惰匹配（Lazy Match）</p><p>我们来试一下：</p><img src="/posts/442cf661/e2e9e9b4783387752ec53d83c06df0b1_MD5.webp" class="" title="21.png"><h3 id="2、两个实例加深理解"><a href="#2、两个实例加深理解" class="headerlink" title="2、两个实例加深理解"></a>2、两个实例加深理解</h3><h4 id="1-颜色值的匹配：RGBS值"><a href="#1-颜色值的匹配：RGBS值" class="headerlink" title="1.颜色值的匹配：RGBS值"></a>1.颜色值的匹配：RGBS值</h4><p>因为RGM码是由<code>#</code>和<code>6位十六进制字符</code>组成；</p><p>首先要匹配，颜色匹配符前边的<code>#</code>号；因为RGM是十六进制的，所以只能取自<code>a-f</code>和<code>A-F</code>和<code>0-9</code>之间； 并且长度一定是6位，最后<code>\b</code>作为边界值，避免不是RGM颜色的代码被识别。 一起在编译器里看一下：</p><p><img src="/posts/442cf661/7bf4f6a7a8c4ea466194d6253da3af9a_MD5.webp" alt="22.png"></p><p>可以得到预期匹配值。</p><h4 id="2-ipv4-地址匹配"><a href="#2-ipv4-地址匹配" class="headerlink" title="2.ipv4 地址匹配"></a>2.ipv4 地址匹配</h4><p>其实Ipv4地址是由四段代码实现的，数字之间由句号隔开；如果要在文本中提取所有出现的ip地址</p><p>可以直接使用<code>\d+\.d+\.d+\.d+</code>来进行匹配；</p><p><strong>思路1）首先<code>\d+ </code>会匹配所有的数字；</strong></p><p><img src="/posts/442cf661/1d667cb09bd0abfcdb5f791319cd6fa4_MD5.webp" alt="23.png"></p><p>这里可以看到成功的匹配到了ipv4地址；</p><p>但是还存在一个问题；ip地址都是八位的，也就是它的范围介于<code>0-255</code>之间</p><p>但是256很明显超出了范围，但是还是被匹配了。</p><p><strong>2)这时候就需要换一种思路：</strong></p><p>首先匹配25，然后第二位取[0-5]之间的数字 : <code>25[0-5]</code>;</p><p>其次如果它的第一个字母是2，第二个字母是[0-4]之间的，最后一位可以取0-9之间的任意值用<code> \d</code>表示 : <code>2[0-4]\d</code>;</p><p>如果第一位是[01],那么最后两位可以取00-99之间的任意数字这里用\d\d表示:<code>[01]\d\d</code></p><p>这三种情况中间用 <code>|</code> 号连接；</p><p>但是有时候，IP地址每一段也可以是两位数字甚至一位数字，这时候就可以直接在后两位数字后边加 <code>？</code>来表示。这时候数字部分就匹配完成：<code>25[0-5]|2[0-4]\d|[01]?\d\d?</code></p><p>我们需要匹配三次<code> ((25[0-5]|2[0-4]\d|[01]?\d\d?)\.)&#123;3&#125;</code>;把前三段数字和后边的句点匹配完毕；</p><p>然后后边的代码还需要重复前边三段的代码 ;最后需要在收尾都加入 <code>\ b</code> 来匹配字符的边界；</p><p>然后看一下完整代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\b((25[0-5]|2[0-4]\d|[01]?\d\d?)\.)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d\d?)\b</span><br></pre></td></tr></table></figure><p><img src="/posts/442cf661/dc5f58d062f097c6d06a22f3c42f3990_MD5.webp" alt="25.png"></p><p>这里看出我们已经可以匹配到预期的完整字符。</p><h2 id="四、正则表达式常用语法"><a href="#四、正则表达式常用语法" class="headerlink" title="四、正则表达式常用语法"></a>四、正则表达式常用语法</h2><h3 id="1-Flags（标志符或修饰符）"><a href="#1-Flags（标志符或修饰符）" class="headerlink" title="1.Flags（标志符或修饰符）"></a><strong>1.Flags（标志符或修饰符）</strong></h3><p><code>g</code>：全局匹配（global）；正则表达式默认只会返回第一个匹配结果，使用标志符g则可以返回所有匹配</p><p><code>i</code>：忽略大小写（case-insensitive）；在匹配时忽略英文字母的大小写</p><p><code>m</code>：多行匹配（multiline）；将开始和结束字符（^和$）视为在多行上工作，即分别匹配每一行（由 \n 或 \r 分割）的开始和结束，而不只是只匹配整个输入字符串的最开始和最末尾处</p><h3 id="2-Character-Sets（字符集合）"><a href="#2-Character-Sets（字符集合）" class="headerlink" title="2. Character Sets（字符集合）"></a>2. <strong>Character Sets（字符集合）</strong></h3><p>用于匹配字符集合中的任意一个字符，常见的字符集有：</p><p><code>[xyz]</code>：匹配 “x”或”y”&#96;&#96;”z”</p><p><code>[^xyz]</code>：补集，匹配除 “x” “y” “z”的其他字符</p><p><code>[a-z]</code>：匹配从 “a” 到 “z” 的任意字符</p><p><code>[^a-n]</code>：补集，匹配除 “a” 到 “n” 的其他字符</p><p><code>[A-Z]</code>：匹配从 “A” 到 “Z” 的任意字符</p><p><code>[0-9]</code>：匹配从 “0” 到 “9” 的任意数字</p><p>比如匹配所有的字母和数字可以写成：<code>/[a-zA-Z0-9]/</code> 或者 <code>/[a-z0-9]/i</code>。</p><h3 id="3-Quantifiers-量词"><a href="#3-Quantifiers-量词" class="headerlink" title="3. Quantifiers (量词)"></a>3. <strong>Quantifiers (量词)</strong></h3><p>在实际使用中常需要匹配同一类型的字符多次，比如匹配 11 位的手机号，我们不可能将 [0-9] 写 11 遍，此时可以使用 Quantifiers 来实现重复匹配。</p><p><code>&#123;n&#125;</code>：匹配 n 次</p><p><code>&#123;n,m&#125;</code>：匹配 n-m 次</p><p><code>&#123;n,&#125;</code>：匹配 &gt;&#x3D;n 次</p><p><code>?</code>：匹配 0 || 1 次</p><p><code>*</code>：匹配 &gt;&#x3D;0 次，等价于 {0,}</p><p><code>+</code>：匹配 &gt;&#x3D;1 次，等价于 {1,}</p><h3 id="4-Metacharacters（元字符）"><a href="#4-Metacharacters（元字符）" class="headerlink" title="4. Metacharacters（元字符）"></a>4. <strong>Metacharacters（元字符）</strong></h3><p>常见的元字符有：</p><p><code>\d</code>：匹配任意数字，等价于 [0-9]</p><p><code>\D</code>：匹配任意非数字字符；\d 的补集</p><p><code>\w</code>：匹配任意基本拉丁字母表中的字母和数字，以及下划线；等价于 [A-Za-z0-9_]</p><p><code>\W</code>：匹配任意非基本拉丁字母表中的字母和数字，以及下划线；\w 的补集</p><p><code>\s</code>：匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格</p><p><code>\S</code>：匹配一个非空白符；\s的补集</p><p><code>\b</code>：匹配一个零宽单词边界，如一个字母与一个空格之间；例如，&#x2F;\bno&#x2F; 匹配 “at noon” 中的 “no”，&#x2F;ly\b&#x2F; 匹配 “possibly yesterday.” 中的 “ly”</p><p><code>\B</code>：匹配一个零宽非单词边界，如两个字母之间或两个空格之间；例如，&#x2F;\Bon&#x2F; 匹配 “at noon” 中的 “on”，&#x2F;ye\B&#x2F; 匹配 “possibly yesterday.”中的 “ye”</p><p><code>\t</code>：匹配一个水平制表符（tab)</p><p><code>\n</code>：匹配一个换行符（newline)</p><p><code>\r</code>：匹配一个回车符（carriage return)</p><h3 id="5-贪婪-x2F-懒惰匹配（Greedy-x2F-Lazy-Match）"><a href="#5-贪婪-x2F-懒惰匹配（Greedy-x2F-Lazy-Match）" class="headerlink" title="5.贪婪&#x2F;懒惰匹配（Greedy&#x2F;Lazy Match）"></a>5.贪婪&#x2F;懒惰匹配（Greedy&#x2F;Lazy Match）</h3><p><code>&lt;.+&gt;</code>: 默认贪婪匹配“任意字符”； <code>&lt;.+?&gt;</code>: 懒惰匹配“任意字符”；</p><p>总结：其实正则表达式还有许多高级概念，如果大家想深入学习： 我推荐大家可以看一下这个视频和文章：(目前也在学习)</p><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV19t4y1y7qP?from=search&seid=12985365724945943801&spm_id_from=333.337.0.0">正则表达式30分钟入门教程</a></p><p><a href="https://juejin.cn/post/6844903487155732494">还有《js正则迷你书》作者的原著文章</a></p><p>好啦其实就是分享一些很基础的东西，技术有限。欢迎大家一起讨论学习。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文讲明白优先级队列为啥按less排序却是从大到小（转载）</title>
      <link href="/posts/14f84af5.html"/>
      <url>/posts/14f84af5.html</url>
      
        <content type="html"><![CDATA[<h2 id="文章出处"><a href="#文章出处" class="headerlink" title="文章出处"></a>文章出处</h2><p><a href="https://www.nowcoder.com/discuss/353157843169779712">牛客网-wayneYM</a></p><h2 id="一文讲明白优先级队列为啥按less排序却是从大到小"><a href="#一文讲明白优先级队列为啥按less排序却是从大到小" class="headerlink" title="一文讲明白优先级队列为啥按less排序却是从大到小"></a>一文讲明白优先级队列为啥按less排序却是从大到小</h2><p>写在前面: 如果你一直纠结为啥自定义明明是greater&lt;&gt;但是出堆却是从小到大，看完这篇文章你就懂了！</p><h2 id="优先级队列-Priority-queue"><a href="#优先级队列-Priority-queue" class="headerlink" title="优先级队列 Priority_queue"></a>优先级队列 Priority_queue</h2><p>这是一个<strong>拥有权值queue</strong>，其内部元素按照元素的权值排列。<strong>权值较高者排在最前优先出队</strong>。其中缺省情况下系统是通过一个<strong>max-heap以堆实现</strong>完成排序特性，表现为一个以vector表现的完全二叉树。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>priority_queue&lt;Type, Container, Functional&gt;</code></p><p>其中Type代表数据类型，Container代表容器类型，缺省状态为vector; Function是比较方式，默认采用的是大顶堆(less&lt;&gt;)。</p><blockquote><p>&#x2F;&#x2F;升序队列  小顶堆 great 小到大<br>priority_queue &lt;int,vector<int>,greater<int> &gt; pq;<br>&#x2F;&#x2F;降序队列  大顶堆 less  大到小 默认<br>priority_queue &lt;int,vector<int>,less<int> &gt; pq;</p></blockquote><h3 id="包含的方法"><a href="#包含的方法" class="headerlink" title="包含的方法"></a>包含的方法</h3><ul><li>top() 访问队头</li><li>empty()</li><li>size()</li><li>push() &#x2F; emplace</li><li>pop</li><li>swap</li></ul><h2 id="如何自定义比较函数-主要讲仿函数已了解可跳过"><a href="#如何自定义比较函数-主要讲仿函数已了解可跳过" class="headerlink" title="如何自定义比较函数(主要讲仿函数已了解可跳过)"></a>如何自定义比较函数(主要讲仿函数已了解可跳过)</h2><h3 id="利用std比较函数的实例"><a href="#利用std比较函数的实例" class="headerlink" title="利用std比较函数的实例"></a>利用std比较函数的实例</h3><p><code>std</code>自带**_greater<int>_和_less<int>_两个比较方法。<strong>他们实现过程使用的是</strong>仿函数**和类模板。</p><h4 id="仿函数的理解"><a href="#仿函数的理解" class="headerlink" title="仿函数的理解"></a>仿函数的理解</h4><p>greater和less是std实现的两个仿函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//注意到  return的符号和名字是相同的。</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">struct</span> <span class="title class_">greater</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp; x,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> T &amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">bool</span> result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp; x,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> T &amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="operator-的重载"><a href="#operator-的重载" class="headerlink" title="operator()的重载"></a>operator()的重载</h5><p>这个可以重载括号运算符，与&#x3D;&#x3D;，&lt;，&gt;这类运算符相同。</p><p>案例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出10</span></span><br></pre></td></tr></table></figure><h5 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h5><p>仿函数就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。</p><ul><li>仿函数是一个类，不是函数</li><li>仿函数重载了()，使得可以类似调用函数那样调用实例。(所以大小堆的调用是greater<int>() ,就是类似调用函数的，实际上是一个叫greater的模板类，输入的参数类型是int，()是这个模板类的一个函数)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CMP_LES = <span class="number">-1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CMP_EQU = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CMP_BIG = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comparer</span> &#123; <span class="comment">//比较的模板类(还不够泛化)</span></span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">Comparer</span>(<span class="type">int</span> cmpType) &#123;</span><br><span class="line">        m_cmpType = cmpType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> res;</span><br><span class="line">        <span class="keyword">switch</span> (m_cmpType) &#123;</span><br><span class="line">            <span class="keyword">case</span> CMP_LES:</span><br><span class="line">                res = num1 &lt; num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CMP_EQU:</span><br><span class="line">                res = num1 == num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CMP_BIG:</span><br><span class="line">                res = num1 &gt; num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>: <span class="type">int</span> m_cmpType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp; num1, <span class="type">int</span> &amp; num2)</span> </span>&#123; <span class="comment">//数字交换</span></span><br><span class="line">    <span class="type">int</span> temp = num1;</span><br><span class="line">    num1 = num2;</span><br><span class="line">    num2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Comparer &amp; cmp)</span> </span>&#123; <span class="comment">//对长度为size的array进行排序  使用cmp这个类方法  cmp就是仿函数的用法</span></span><br><span class="line">    <span class="comment">//冒泡</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> indx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(array[indx], array[j])) <span class="comment">//仿函数  此处虽然cmp是一个类，但是用法像一个函数</span></span><br><span class="line">            &#123;</span><br><span class="line">                indx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (indx != i) &#123;</span><br><span class="line">            <span class="built_in">Swap</span>(array, array[indx]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListArray</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; array &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARY_SIZE 10</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[ARY_SIZE] = &#123;</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">        <span class="number">12</span>,</span><br><span class="line">        <span class="number">9</span>,</span><br><span class="line">        <span class="number">31</span>,</span><br><span class="line">        <span class="number">93</span>,</span><br><span class="line">        <span class="number">34</span>,</span><br><span class="line">        <span class="number">98</span>,</span><br><span class="line">        <span class="number">9</span>,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">20</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The initial array is : &quot;</span>;</span><br><span class="line">    <span class="built_in">ListArray</span>(array, ARY_SIZE);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">SortArray</span>(array, ARY_SIZE, <span class="built_in">Comparer</span>(CMP_BIG));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The ascending sorted array is :&quot;</span>;</span><br><span class="line">    <span class="built_in">ListArray</span>(array, ARY_SIZE);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">SortArray</span>(array, ARY_SIZE, <span class="built_in">Comparer</span>(CMP_LES));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The descending sorted array is : &quot;</span>;</span><br><span class="line">    <span class="built_in">ListArray</span>(array, ARY_SIZE);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>The initial array is : 10 12 9 31 93 34 98 9 1 20</p><p>The ascending sorted array is :1 9 9 10 12 20 31 34 93 98</p><p>The descending sorted array is : 98 93 34 31 20 12 10 9 9 1</p><p>49行处<strong>虽然cmp是一个类</strong>，但是用法像一个函数，即仿函数的意义</p><h4 id="greater和less的代码实现"><a href="#greater和less的代码实现" class="headerlink" title="greater和less的代码实现"></a>greater和less的代码实现</h4><p>greater定义如下</p><blockquote><p><code>template &lt;class T&gt; struct greater&#123;</code><br>    <code>bool operate() (const T&amp; x, const T &amp;y) const&#123;return x&gt;y;&#125;</code><br>    <code>typedef T first_argument_type;</code><br>    <code>typedef T second_argument_type;</code><br>    <code>typedef bool result_type;</code><br><code>&#125;</code></p></blockquote><p>less定义如下</p><blockquote><p><code>template &lt;class T&gt; struct less &#123;</code><br>    <code>bool operator() (const T&amp; x, const T&amp; y) const &#123;return x&lt;y;&#125;</code><br>    <code>typedef T first_argument_type;</code><br>    <code>typedef T second_argument_type;</code><br>    <code>typedef bool result_type;</code><br><code>&#125;;</code></p></blockquote><p>常见实例</p><blockquote><p>&#x2F;&#x2F;升序队列  小顶堆 great 小到大<br>priority_queue &lt;int,vector<int>,greater<int> &gt; pq;&#x2F;&#x2F;升序<br>&#x2F;&#x2F;降序队列  大顶堆 less  大到小 默认<br>priority_queue &lt;int,vector<int>,less<int> &gt; pq;&#x2F;&#x2F;降序</p><p>实际上是保持优先级最高的元素在[0]的位置，每次pop或者push操作会更新<br>声明参数<br>priority_queue&lt;Type, Container, Funcitonal&gt;;<br>priority_queue&lt;pair&lt;int,int&gt; &gt; pq_pair;&#x2F;&#x2F;结果先按照pair的first元素降序，first元素相等再按照second元素降序<br>priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt;</p></blockquote><h2 id="sort和priority-queue为什么顺序不同"><a href="#sort和priority-queue为什么顺序不同" class="headerlink" title="!!sort和priority_queue为什么顺序不同"></a>!!sort和priority_queue为什么顺序不同</h2><p><strong>可以发现对于sort和priority_queue，使用greater和less类模板是结果不同的。</strong></p><p>主要原因是因为priority_queue的内部实现方法是堆，less对应的是大顶堆。在此排序下调用top()得到的是堆顶，也就是取值时是从大到小。push对应的底层函数是push_heap()，每次添加元素入堆时，在默认情况下添加进去的数据作为较小值入堆。</p><p><strong>顺序真正不同的根本原因</strong></p><p>堆的内部实现是vector，每次出堆的时候 实际上是<strong>堆顶元素和最后一个元素互换(把最大元素沉到数组末端)<strong>。那么实际上假如没有出堆这一个过程而是继续将数据缓存在vector中，所有元素出堆后，形成的数组就是升序的。只是</strong>由于出堆这一过程导致了元素出堆反序了</strong>，相当于逆序输出。</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>例如排好的大顶堆[9，5，7，3]。(9是根节点)<br><strong>第一次出堆</strong>的时候9会被移到最后与3交换位置，同时会对3进行下沉保证堆结构，9出堆。<br>[3，5，7，9]-&gt;[7，5，3，|9] (|后的数字代表已经出堆)<br><strong>第二次出堆</strong> 7与3交换位置。( 此时9已经出堆了，只是为了方便后续表达所以保留)<br>[3，5，|7，9]-&gt;[5，3，|7，9]<br><strong>第三次出堆</strong> 5与3交换位置。5出堆<br>[5，3，|7，9]-&gt;[3，|5，7，9]<br><strong>第四次出堆</strong> 3出堆，此时堆为空<br>[|3，5，7，9]<br>可以观察到，假如我们将出堆的数保留在vector中的话，数字排序确实是递增的(符合less<t>的直观性质)，但是由于出堆的问题，顺序刚好反了过来，所以(less<t>对应的是大顶堆，出堆顺序是从大到小)</t></t></p><ol><li>n个无序元素构成大顶堆(最后一个节点上浮)</li><li>根节点和最后一个元素交换</li><li>剩下n-1个元素重新构成大顶堆(根节点下沉)</li><li>重复2，3直到数组排序完毕</li></ol><blockquote><p><code>//默认都是less</code><br><code>sort(vec.begin(),vec.end(),less&lt;int&gt;());               //内置类型从小到大   升序</code><br><code>priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pql;    //top出数据从大到小   降序</code></p><p><code>sort(vec.begin(),vec.end(),greater&lt;int&gt;());            //内置类型从大到小     降序</code><br><code>priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pqg;    //top出数据从小到大   升序</code></p></blockquote><table><thead><tr><th>方法或容器</th><th>less<T>()的顺序(默认)</th><th>greater<T>()的顺序</th><th>cmp函数 &gt;</th></tr></thead><tbody><tr><td>priority_queue 全是反过来的</td><td>降序 大-&gt;小</td><td>升序 小-&gt;大</td><td>升序 小-&gt;大</td></tr><tr><td>sort</td><td>升序 小-&gt;大</td><td>降序 大-&gt;小</td><td></td></tr><tr><td>map</td><td>升序 小-&gt;大</td><td>降序 大-&gt;小</td><td></td></tr><tr><td>map</td><td>升序 小-&gt;大</td><td>降序 大-&gt;小</td><td></td></tr></tbody></table><p><strong>除了priority_queue使用的是堆，导致全部大小比较反了过来，其他均是正常符合逻辑的操作</strong>，即判断为**_func(a,b)_判断为true则a在前**。只有priority_queue特殊，如果<code>func(a,b)</code>判断为true，优先级队列中b在前。</p><p>对比一下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> A[]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N=<span class="built_in">sizeof</span>(A)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(A,A+N)</span></span>;</span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(cout,<span class="string">&quot; &quot;</span>)</span></span>;    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Vector vec contains:&quot;</span>;</span><br><span class="line">    <span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),output);    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\nAfter greater&lt;int&gt;():&quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//内置类型从大到小 </span></span><br><span class="line">    <span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),output);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; pqg;<span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : vec)     pqg.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!pqg.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; pqg.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        pqg.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\nAfter less&lt;int&gt;():&quot;</span>;</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());   <span class="comment">//内置类型小大到大 </span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),output);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; pql;<span class="comment">//降序 大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : vec)  pql.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">while</span>(!pql.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    cout &lt;&lt; pql.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    pql.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义优先级队列实例"><a href="#自定义优先级队列实例" class="headerlink" title="自定义优先级队列实例"></a>自定义优先级队列实例</h2><p><strong>希望排序结果从小到大</strong>，(对应great的小顶堆排序方式)</p><p>！注意，重写的是仿函数不是函数，<strong>cmp应该是一个类或者struct</strong></p><p>注意堆排序导致顺序反了过来，如果<code>cmp(a,b) == true</code>在堆中的排序说明b会在a前面，那么要从小到大，应该用<code>&gt;</code>符号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> a = <span class="number">0</span> ,<span class="type">int</span> b = <span class="number">0</span>): <span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x == b.x)    <span class="keyword">return</span> a.y&gt;b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; ++i)&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="built_in">rand</span>(),<span class="built_in">rand</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;pq.<span class="built_in">top</span>().x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;pq.<span class="built_in">top</span>().y&lt;&lt;endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>希望从大到小排序</strong>，对应less<T>()的排序顺序</p><p>并且利用系统自带的仿函数<code>greater</code>或者<code>less</code>。其中<code>greater</code>使用的是<code>&gt;</code>符号，<code>le***的是</code>&lt;<code>符号。了解原理后实际上重载</code>&lt;或&gt;&#96;均可。</p><p>希望通过<code>less</code>实现，由于less<T>()的实现借助了&lt;，所以可以通过，<strong>重写&lt;符号实现</strong></p><p>需要实现的是less<T>(a,b) &#x3D; true, b会放在前面，此处要实现大的在前，所以要实现<code>less&lt;T&gt;(小数,大数) = true</code>，保留&lt;号原有意义即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> a = <span class="number">0</span> ,<span class="type">int</span> b = <span class="number">0</span>): <span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要注意的是priority_queue默认的优先级计算是less&lt;Node&gt;,所以大顶堆应该重写的是operator&lt;</span></span><br><span class="line"><span class="comment">//注意返回应该是&gt; 虽然着很奇怪</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Node a ,Node b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.y)    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; pq;<span class="comment">//pq队列是从大到小排序的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反之如果希望借助less<T>()实现从小到大排序，则第7 8 行的比较符号应该为&gt;符号。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h3><p>仿函数cmp类体现了priority_queue的用法和注意事项。</p><p>思路全在代码中了，题目本身较容易想出解法，主要在于实现思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> height,overh;</span><br><span class="line">    <span class="built_in">Node</span>():<span class="built_in">height</span>(<span class="number">0</span>), <span class="built_in">overh</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y): <span class="built_in">height</span>(_x), <span class="built_in">overh</span>(_y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(vector&lt;<span class="type">int</span>&gt; x, vector&lt;<span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//前面高的比较少的   拍最前</span></span><br><span class="line">        <span class="comment">//前面高的相同    比较高的排最前</span></span><br><span class="line">        <span class="comment">//先比第二个参数  小到大(就用&gt;号)   然后第一个参数  大到小(小于号&lt;)</span></span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">1</span>]==y[<span class="number">1</span>])    <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">1</span>] &gt; y[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">    <span class="comment">//用优先级队列实现O(n2)时间复杂度</span></span><br><span class="line">    <span class="comment">//先按照前面比当前人高 从小到大排</span></span><br><span class="line">    <span class="comment">//当第一个比较数相同，从大到小插入结果数组  因为从小到大插的话  高的人进入排序可能会影响矮的人  前面比他高的人数  需要判断的东西变多了</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; ,cmp&gt;  pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : people)    pq.<span class="built_in">push</span>(p);</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  ans;</span><br><span class="line">    <span class="type">int</span> over = <span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        over = <span class="number">0</span>,pos =<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;over&lt;&lt;&#x27; &#x27;&lt;&lt;cur[0]&lt;&lt;&#x27; &#x27;&lt;&lt;cur[1]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">while</span>( over &lt; cur[<span class="number">1</span>] )&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;&quot;jinru&quot;&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>( ans[pos][<span class="number">0</span>] &gt;= cur[<span class="number">0</span>] ) over++;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在位置</span></span><br><span class="line">        ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>()+pos, cur);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;pos&lt;&lt;&quot;插入成功&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个分类下的文章都是做什么的？</title>
      <link href="/posts/34c45c83.html"/>
      <url>/posts/34c45c83.html</url>
      
        <content type="html"><![CDATA[<h2 id="这个分类下的文章都是做什么的？"><a href="#这个分类下的文章都是做什么的？" class="headerlink" title="这个分类下的文章都是做什么的？"></a>这个分类下的文章都是做什么的？</h2><p>在学习过程中，我遇到不会的问题经常会去查找别人的博客进行学习。<br>有时候别人的博客已经讲解地非常清楚了，我懒得自己再写一篇新笔记，但是我又害怕笔记之后由于各种原因会失效，所以<strong>这个分类下的文章就是我用来保存别人笔记，方便我自己之后查看用的。</strong><br>不过我这个博客只有我自己在看，应该不会对大佬们产生什么影响。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记转载 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找的边界问题</title>
      <link href="/posts/825ec99a.html"/>
      <url>/posts/825ec99a.html</url>
      
        <content type="html"><![CDATA[<p>在准备机试的时候(2025年03月14日),遇到这道题，第一次没想出来解答，于是查看了官方的解法。<strong>本人想举一反三，将代码进行修改，却发现了原解没遇见的边界问题。</strong>，现分析为什么原代码可以，现在的代码不行</p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">题目链接</a></h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本体的思路我学习的<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solutions/698479/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp">官方题解</a>，思路也搬运过来</p><p><strong>方法：二分查找</strong></p><p><strong>思路与算法</strong></p><p>一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p><img src="/posts/825ec99a/%E6%80%9D%E8%B7%AF1.png" class=""><p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标。</p><p>我们考虑<strong>数组中的最后一个元素 x</strong>：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 x；而在最小值左侧的元素，它们的值一定都严格大于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p><p>在二分查找的每一步中，左边界为 low，右边界为 high，区间的中点为 pivot，最小值就在该区间内。我们将中轴元素<code> nums[pivot]</code> 与右边界元素 <code>nums[high] </code>进行比较，可能会有以下的三种情况：</p><p>第一种情况是 <code>nums[pivot]&lt;nums[high]。</code>如下图所示，这说明 <code>nums[pivot]</code> 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。</p><img src="/posts/825ec99a/%E6%80%9D%E8%B7%AF2.png" class=""><p>第二种情况是 <code>nums[pivot]&gt;nums[high]</code>。如下图所示，这说明 <code>nums[pivot] </code>是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。</p><img src="/posts/825ec99a/%E6%80%9D%E8%B7%AF3.png" class=""><p>由于数组不包含重复元素，并且只要当前的区间长度不为 1，pivot 就不会与 high 重合；而如果当前的区间长度为 1，这说明我们已经可以结束二分查找了。<strong>因此不会存在 <code>nums[pivot]=nums[high] </code></strong> 的情况。</p><p>当二分查找结束时，我们就得到了最小值所在的位置。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector &lt; <span class="type">int</span> &gt; &amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//中止条件为left&lt;right，则循环结束后left=right</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">            <span class="comment">//mid 一定在最小值的左侧</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//注意right与left的处理并不一致。</span></span><br><span class="line">            <span class="comment">//此时的mid可能是最终结果，所以不能直接用mid-1</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么不与num-left-比较"><a href="#为什么不与num-left-比较" class="headerlink" title="为什么不与num[left]比较"></a>为什么不与<code>num[left]</code>比较</h2><p> 我将本题的代码修改，发现会碰见代码出现错误的问题。<strong>而我做的，只是将比较<code>num[right]</code>元素改为比较<code>num[left]</code>元素</strong><br> 代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector &lt; <span class="type">int</span> &gt; &amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现代码运行出错，经过分析，虽然<code>nums[left]</code>与<code>nums[right]</code>只差了一个数，但是用同样的思路是完全不同的结果</p><h3 id="令人迷惑的表象"><a href="#令人迷惑的表象" class="headerlink" title="令人迷惑的表象"></a>令人迷惑的表象</h3><p>我需要对官方题解做下补充：<br>实际上，数组的初始状态有两种：</p><img src="/posts/825ec99a/%E4%B8%A4%E7%A7%8D%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.jpg" class=""><p>但题解对三种情况的处理是没有问题的(pivot对应mid，high对应right，low对应left)（懒得重画图了）:</p><ul><li><code>nums[mid]&lt;nums[right]</code>与<code>nums[mid]&lt;nums[left]</code><img src="/posts/825ec99a/%E6%AF%94%E8%BE%831.jpg" class=""></li><li><code>nums[mid]==nums[right]</code>与<code>nums[mid]==nums[left]</code><img src="/posts/825ec99a/%E6%AF%94%E8%BE%832.jpg" class=""></li><li><code>nums[mid]&gt;nums[right]</code>与<code>nums[mid]&gt;nums[left]</code><img src="/posts/825ec99a/%E6%AF%94%E8%BE%833.jpg" class="">与<code>nums[left]</code>进行比较<strong>似乎</strong>与<code>nums[right]</code><strong>一致</strong>，三种情况，可以<strong>各自确定mid目前和ans的相对前后关系</strong></li></ul><h3 id="为什么会出错？"><a href="#为什么会出错？" class="headerlink" title="为什么会出错？"></a>为什么会出错？</h3><p>着重观察<br><code>nums[mid]&gt;nums[left]</code><br>会发现，在不同的情况下，<strong>mid相对于ans的位置前后关系不同</strong>，并且情况一在一次次递归后可能变为情况2，如图所示：</p><img src="/posts/825ec99a/file-20250315135716861.jpg" class=""><p><strong>与<code>nums[left]</code>进行比较要处理这种mid与ans前后关系发生变化，逻辑处理不如直接与<code>nums[right]</code>进行比较来的方便。</strong></p><h3 id="发散思维"><a href="#发散思维" class="headerlink" title="发散思维"></a>发散思维</h3><p>在分析出错原因时，我们指出left，ans，mid，right的相对关系会发生变化，那么存不存在一种可能，使出现下图的变化？：</p><img src="/posts/825ec99a/%E5%81%87%E6%83%B3%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%98%E5%8C%96%EF%BC%9A.jpg" class=""><p><strong>结论：不可能</strong><br>以下是分析：<br>分析需要借助代码来分析，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变更<code>right</code>条件的是<code>nums[mid]&lt;=nums[right]</code>,之前分析可知，由于数组中没有重复的元素，所以在<code>left==right</code>（即循环结束）前，mid一直是不会与right相等的，所以只有<code>nums[mid]&lt;nums[right]</code>时，<code>right</code>才会发生变化，而到达<strong>情况2便是极限了</strong>，因为直接结束<code>nums[mid]&lt;nums[right]</code>的情况都不会再出现了</p><h2 id="寻找最大值怎么办（还有坑）？"><a href="#寻找最大值怎么办（还有坑）？" class="headerlink" title="寻找最大值怎么办（还有坑）？"></a>寻找最大值怎么办（还有坑）？</h2><h3 id="按照相同的思路分析问题"><a href="#按照相同的思路分析问题" class="headerlink" title="按照相同的思路分析问题"></a>按照相同的思路分析问题</h3><h4 id="与nums-left-比较"><a href="#与nums-left-比较" class="headerlink" title="与nums[left]比较"></a>与<code>nums[left]</code>比较</h4><p>三种情况下，ans与mid的相对情况只有一种</p><img src="/posts/825ec99a/%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC.jpg" class=""><h4 id="与nums-right-比较"><a href="#与nums-right-比较" class="headerlink" title="与nums[right]比较"></a>与<code>nums[right]</code>比较</h4><p>我们发现在<code>nums[mid]&lt;nums[right]</code>时，<code>ans与mid</code>有<strong>两种相对位置</strong></p><img src="/posts/825ec99a/%E6%9C%80%E5%A4%A7%E5%80%BC-right.jpg" class=""><p>理所应该，以下情况是可能出现的</p><img src="/posts/825ec99a/%E6%9C%80%E5%A4%A7%E5%80%BC-right2.jpg" class=""><p>所以，<strong>找最小值时为什么不用left和找最大值为什么不用right的原因是相同的：可能一种情况需要处理两套相对关系</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpeek</span><span class="params">(vector &lt; <span class="type">int</span> &gt; &amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[l]) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎我们使用<code>num[left]</code>就完事大吉了，但实际应用不是这样的。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>测试发现大部分代码可以通过，但是存在一个<strong>测试案例超时</strong></p><img src="/posts/825ec99a/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%B6%85%E6%97%B6.png" class=""><p>奇怪的是,使用<code>findMin</code>代码寻找最小值，却可以得出正确的结果</p><img src="/posts/825ec99a/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C2.png" class=""><p>经过分析，我们发现，<br><code>mid=(left+right)/2</code>的公式mid边界情况有些特殊，不能想当然。二者之和不为偶数，那么mid值会<strong>偏左</strong>，导致：</p><ul><li><strong>只有数组长度不为1时，<code>mid==right</code>不可能</strong></li><li><strong>但是数组长度不为1时,<code>mid==left</code>是可能的。</strong> <strong>长度还有可能为2</strong> <code>mid=(left+right)/2=left+(right-left)/2</code>,如果长度大于2，<code>mid也一定不等于left</code></li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="一、将寻找最小值的结果修改一下"><a href="#一、将寻找最小值的结果修改一下" class="headerlink" title="一、将寻找最小值的结果修改一下"></a>一、将寻找最小值的结果修改一下</h4><p>既然寻找最大值的坑这么多，我们可以先寻找一个最小值：</p><ul><li>若最小值下标为0，最大值即为最后一个元素，</li><li>若最小值下标i不为0，最大值即为<code>nums[i-1]</code><img src="/posts/825ec99a/%E8%A1%A8%E6%83%85%E5%8C%851.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findpeek</span><span class="params">(vector &lt; <span class="type">int</span> &gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">findmin</span>(nums);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二、增加数组长度不为1时，mid-left的判断"><a href="#二、增加数组长度不为1时，mid-left的判断" class="headerlink" title="二、增加数组长度不为1时，mid==left的判断"></a>二、增加数组长度不为1时，<code>mid==left</code>的判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpeek</span><span class="params">(vector &lt; <span class="type">int</span> &gt; &amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[l]) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[l]) &#123;</span><br><span class="line"><span class="comment">//l==r时，循环终止，所以此时数组长度一定大于1</span></span><br><span class="line"><span class="comment">//由于此时长度最大为2，所以长度只能为2</span></span><br><span class="line"><span class="keyword">return</span> nums[l]&gt;nums[r]?nums[l]:nums[r];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的前中后三序遍历</title>
      <link href="/posts/f1a64171.html"/>
      <url>/posts/f1a64171.html</url>
      
        <content type="html"><![CDATA[<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">前序遍历</a></h2><p>二叉树结构</p><img src="/posts/f1a64171/%E4%BA%8C%E5%8F%89%E6%A0%91.png" class=""><p>-前序遍历结果：1-2-4-5-6-7-3-8-9</p><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line"><span class="built_in">pre</span>(root-&gt;left,res);</span><br><span class="line"><span class="built_in">pre</span>(root-&gt;right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代（非递归）遍历"><a href="#迭代（非递归）遍历" class="headerlink" title="迭代（非递归）遍历"></a>迭代（非递归）遍历</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h4><p>步骤（思路）：<br>    1. 沿着根的左孩子，依次<strong>入栈并访问</strong>，直到左孩子为空<br>    2. 栈顶元素<strong>出栈</strong>：<br>            若其右孩子为空，继续步骤2；<br>            若右孩子不空，将右子树执行步骤1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; mystack;</span><br><span class="line">        TreeNode* temp=root;</span><br><span class="line">        <span class="comment">//沿着根的左孩子，依次入栈并访问，直到左孩子为空</span></span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            mystack.<span class="built_in">push</span>(temp);</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            temp=temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(mystack.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            temp=mystack.<span class="built_in">top</span>();</span><br><span class="line">            mystack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//若右孩子不空，将右子树执行步骤1</span></span><br><span class="line">            <span class="comment">//若其右孩子为空，继续步骤2(继续循环)</span></span><br><span class="line">            temp=temp-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                mystack.<span class="built_in">push</span>(temp);</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                temp=temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h4><p>步骤（思路）：<br>    1. 将根压入栈中；<br>    2. 栈顶元素<strong>出栈并访问</strong>：<br>            <strong>先右后左</strong>，将孩子依次压入栈中。<br>            重复步骤一直至栈为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; mystack;</span><br><span class="line">        mystack.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(mystack.<span class="built_in">size</span>())&#123;</span><br><span class="line">            temp=mystack.<span class="built_in">top</span>();</span><br><span class="line">            mystack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                mystack.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">                mystack.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">中序遍历</a></h2><img src="/posts/f1a64171/%E4%BA%8C%E5%8F%89%E6%A0%91.png" class=""><p>-中序遍历结果：4-2-6-5-7-1-3-9-8</p><h3 id="递归遍历-1"><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mid</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mid</span>(root-&gt;left,res);</span><br><span class="line">res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line"><span class="built_in">mid</span>(root-&gt;right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代（非递归）遍历-1"><a href="#迭代（非递归）遍历-1" class="headerlink" title="迭代（非递归）遍历"></a>迭代（非递归）遍历</h3><p>步骤（思路）：<br>    1. 沿着根的左孩子，依次<strong>入栈</strong>，直到左孩子为空<br>    2. 栈顶元素<strong>出栈并访问</strong>：<br>            若其右孩子为空，继续步骤2；<br>            若右孩子不空，将右子树执行步骤1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; mystack;</span><br><span class="line">        TreeNode* temp=root;</span><br><span class="line">        <span class="comment">//沿着根的左孩子，依次入栈，直到左孩子为空</span></span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            mystack.<span class="built_in">push</span>(temp);</span><br><span class="line">            temp=temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(mystack.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//栈顶元素出栈并访问</span></span><br><span class="line">            temp=mystack.<span class="built_in">top</span>();</span><br><span class="line">            mystack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            <span class="comment">//若右孩子不空，将右子树执行步骤1</span></span><br><span class="line">            <span class="comment">//若其右孩子为空，继续步骤2(继续循环)</span></span><br><span class="line">            temp=temp-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                mystack.<span class="built_in">push</span>(temp);</span><br><span class="line">                temp=temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意到：该实现与前序遍历的迭代遍历中思路一高度相似：<strong>按照先序序列进栈，出栈的序列一定是一个中序序列</strong>(该结论必定正确，帮助记忆前序遍历与中序遍历，但是不需要证明)</p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">后序遍历</a></h2><img src="/posts/f1a64171/%E4%BA%8C%E5%8F%89%E6%A0%91.png" class=""><p>-后序遍历结果：4-6-7-5-2-9-8-3-1</p><h3 id="递归遍历-2"><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">postorder</span>(root-&gt;left,res);</span><br><span class="line"><span class="built_in">postorder</span>(root-&gt;right,res);</span><br><span class="line">res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代-非递归-遍历"><a href="#迭代-非递归-遍历" class="headerlink" title="迭代(非递归)遍历"></a>迭代(非递归)遍历</h3><p>步骤（思路）：<br>    1. 沿着根的左孩子，依次<strong>入栈</strong>，直到左孩子为空<br>    2.扫描栈顶元素：<br>        若无右孩子,<strong>弹出并访问,修改辅助指针</strong>。<br>        若有右孩子：<br>            右孩子未被访问过，将右孩子视为根节点执行步骤一。<br>            右孩子已被访问过，不再访问右孩子。<br>利用一个<strong>辅助指针</strong>记录上一个被访问的结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; mystack;</span><br><span class="line">        TreeNode *temp, *last;</span><br><span class="line">        temp = root;</span><br><span class="line">        last = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            mystack.<span class="built_in">push</span>(temp);</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (mystack.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            temp = mystack.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!temp-&gt;right) &#123;</span><br><span class="line">                mystack.<span class="built_in">pop</span>();</span><br><span class="line">                last = temp;</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right == last) &#123;</span><br><span class="line">                    mystack.<span class="built_in">pop</span>();</span><br><span class="line">                    last = temp;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">                        mystack.<span class="built_in">push</span>(temp);</span><br><span class="line">                        temp = temp-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081_2020_Lab6:Copy-on-Write</title>
      <link href="/posts/e18dbd36.html"/>
      <url>/posts/e18dbd36.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是copy-on-write-写时复制-？"><a href="#一、什么是copy-on-write-写时复制-？" class="headerlink" title="一、什么是copy-on write(写时复制)？"></a>一、什么是<code>copy-on write</code>(写时复制)？</h2><p>xv6中的<code>fork()</code>系统调用将父进程的所有用户空间内存复制到子进程中*(同样<code>linux </code>中除<code>pid=1</code>的进程外所有的进程都是<code>fork</code>出来的)*。如果父进程较大，则复制可能需要很长时间。更糟糕的是，这项工作经常造成大量浪费；例如，子进程中的<code>fork()</code>后跟<code>exec()</code>将导致子进程丢弃复制的内存，而其中的大部分可能都从未使用过。另一方面，如果父子进程都使用一个页面，并且其中一个或两个对该页面有写操作，则确实需要复制。</p><p><code>copy-on-write (COW) </code>的<strong>目标是推迟到子进程实际需要物理内存拷贝时再进行分配和复制物理内存页面。</strong></p><p><code>COW</code>只为子进程创建一个页表，用户内存的PTE指向父进程的物理页。<code>COW</code>将父进程和子进程中的所有用户PTE标记为不可写。当任一进程试图写入其中一个<code>COW</code>页时，CPU将强制产生页面错误(<code>page fault</code>)。内核页面错误处理程序检测到这种情况将为出错进程分配一页物理内存，将原始页复制到新页中，并修改出错进程中的相关PTE指向新的页面，将PTE标记为可写。当页面错误处理程序返回时，用户进程将能够写入其页面副本。</p><p><code>COW</code>将使得释放用户内存的物理页面变得更加棘手。给定的物理页可能会被多个进程的页表引用，并且只有在最后一个引用消失时才应该被释放。</p><p>我们可以看出来 <code>COW</code>与<code>lazy allocation</code>相似，都是在进程要求分配内存的时候，不实际分配物理地址，等到发生<code>page fault</code>后再进行处理。**<code>page fault</code>是<code>cow</code>与<code>lazy allocation</code>的核心**</p><h2 id="二、如何实现copy-on-write"><a href="#二、如何实现copy-on-write" class="headerlink" title="二、如何实现copy-on write"></a>二、如何实现<code>copy-on write</code></h2><h3 id="1-修改fork-函数"><a href="#1-修改fork-函数" class="headerlink" title="1.修改fork()函数"></a>1.修改<code>fork()</code>函数</h3><p>子进程都是由父进程<code>fork</code>而来，想要实现<code>copy-on write</code>，需要我们对<code>fork</code>函数做修改。</p><p>原本的<code>fork()</code>函数会将父进程的所有数据都复制到子进程。修改后的<code>fork()</code>函数需要将子进程内存的PTE指向父进程，权限相关的讨论我们之后进行。</p><p>修改前的fork函数如下：</p><img src="/posts/e18dbd36/%E4%BF%AE%E6%94%B9%E5%89%8D%E7%9A%84fork%E5%87%BD%E6%95%B0.png" class="" title="修改前的fork函数."><p>修改后的fork函数如下：</p><img src="/posts/e18dbd36/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84fork%E5%87%BD%E6%95%B0.png" class="" title="修改后的fork函数"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fork()函数 从已经存在的进程中创建一个子进程，而原进程称为父进程。fork函数 需要为新子进程生成pid等功能，uvmcopy函数负责将</span></span><br><span class="line"><span class="comment">//父进程的pte所指的值复制给子进程</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-子进程如何共享父进程的地址空间？"><a href="#1-1-子进程如何共享父进程的地址空间？" class="headerlink" title="1.1 子进程如何共享父进程的地址空间？"></a>1.1 子进程如何共享父进程的地址空间？</h4><h5 id="1-1-1-方法一、复制页表-pagetable-的值"><a href="#1-1-1-方法一、复制页表-pagetable-的值" class="headerlink" title="1.1.1 方法一、复制页表(pagetable)的值"></a>1.1.1 方法一、复制页表<code>(pagetable)</code>的值</h5><img src="/posts/e18dbd36/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="" title="页表结构"><p>第一种方法，在<code>fork</code>函数新建子进程时，直接将子进程的<code>pagetable</code>值赋值父进程的<code>pagetable</code>值。</p><p>这种方法在复制时快速有效，但是存在以下几个问题：</p><p>(1).倘若进程2修改物理内存<code>A</code>的数据，为了不影响父进程，父进程对应的物理内存数据不能发生改变。只有进程2从<code>Pagetable</code>开始修改，重新建立<code>level2</code>、<code>level1</code>、<code>level0</code>级页表,B页表指向新的物理内存才可以实现。<strong>同时，考虑到内存引用计数机制的需求，该方法无法正确判断一个物理页面的引用计数</strong>，因为直接复制了<code>pagetable</code>，没有牵扯到最低级的物理内存。</p><p>所以该方法<strong>不满足</strong>需求。</p><h5 id="1-1-2-方法二、仅将最后一级PTE的值指向物理内存"><a href="#1-1-2-方法二、仅将最后一级PTE的值指向物理内存" class="headerlink" title="1.1.2 方法二、仅将最后一级PTE的值指向物理内存"></a>1.1.2 方法二、仅将最后一级PTE的值指向物理内存</h5><img src="/posts/e18dbd36/%E4%BF%AE%E6%94%B9%E5%90%8Efork%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="" title="image-20240522133436582"><p>第二种方法，在<code>fork</code>函数新建子进程时，子进程自建完整的页表结构，只将最后一级<code>PTE</code>指向与父进程相同的物理内存。</p><p><strong>该方法由于直接涉及到了物理内存，方便加入引用计数机制</strong>，同时，当需要向页面写入数据时，只需要修改最低级<code>PTE</code>所指的物理内存即可。</p><p>该方法<strong>满足</strong>需求。</p><h3 id="2-权限问题"><a href="#2-权限问题" class="headerlink" title="2.权限问题"></a>2.权限问题</h3><p><strong>写时复制将父进程和子进程中的所有用户PTE标记为不可写。当任一进程试图写入其中一个COW页时，CPU将强制产生页面错误。</strong>这样做缺少分辨父进程原本有无权限的有限方法，<strong>需要我们增加标志位来辅助辨别。</strong></p><p>XV6操作系统的权限管理比较简单，没有支持<code>Linux</code>的多用户权限，XV6通过<code>PTE</code>低10位作为Flag标志位来管理权限。</p><img src="/posts/e18dbd36/%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98.png" class="" title="image-20240522151206552"><p>低8位与低9位被保留下来，作为拓展标志位使用。我们可以利用<strong>低8位作为COW标志位</strong>。</p><p><strong>父进程原本拥有对物理内存的写权限，父子进程COW位被设为1.</strong><br><strong>父进程原本未拥有对物理内存的写权限，父子进程COW位被设为0.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *oldpte;</span><br><span class="line">  <span class="type">pte_t</span> *newpte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  <span class="comment">//uint flags;</span></span><br><span class="line">  <span class="comment">//char *mem;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((oldpte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: oldpte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*oldpte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: oldpage not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*oldpte);</span><br><span class="line">    <span class="comment">//flags=PTE_FLAGS(*oldpte);</span></span><br><span class="line">    <span class="keyword">if</span>(*oldpte&amp;PTE_W)&#123;</span><br><span class="line">      *oldpte=*oldpte&amp;(~PTE_W);</span><br><span class="line">      *oldpte=*oldpte|PTE_RSW;</span><br><span class="line">      <span class="comment">//flags=PTE_FLAGS(*oldpte);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((newpte = walk(new, i, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: newpte should exist&quot;</span>);</span><br><span class="line">    addpgcnt(PGROUNDDOWN(pa));</span><br><span class="line">    *newpte=*oldpte;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-引用计数"><a href="#3-引用计数" class="headerlink" title="3.引用计数"></a>3.引用计数</h3><p>原本的XV6操作系统中，由于<code>fork</code>函数会将父进程的用户空间完全复制到新的物理内存中再映射给子进程。进程在释放物理内存等操作时不需要考虑到其父进程或子进程使用同一物理内存的情况，在增加写时复制机制后，XV6操作系统在处理某进程由于写操作引起的页面错误时必须保证其他进程的正常运行，所以为物理内存增加引用计数是必要的。</p><p><strong>需要引用计数辅助决定需要写入数据的进程是否需要额外申请物理内存</strong>。</p><p>当引用计数大于1时，写入数据的进程需要自己申请一块空闲内存，该内存的数据复制自原本将写入的内存，进程最后一级的<code>PTE</code>指向新分配的物理内存，再进行自己的写入操作。同时旧物理内存的引用数需要减1。</p><p>当引用计数等于1时，直接写入数据即可。</p><h4 id="引用计数功能的实现"><a href="#引用计数功能的实现" class="headerlink" title="引用计数功能的实现"></a>引用计数功能的实现</h4><p>XV6操作系统<strong>原本的物理内存分配与回收机制</strong>是将将空闲的物理内存地址空间以页(4096个字节)为单位，使用链表结构将页整理起来。进程申请物理内存时，操作系统从链表中取出一个物理内存分配给进程，当进程结束时，操作系统回收页表将其加入空闲链表中。</p><p>引用计数功能的实现不需要对原本页表的分配释放机制做出太大的改变：</p><p>XV6操作系统参与分配的页表数量是固定的(<code>PHYSTOP/PGSIZE</code>)，使用一个固定大小的数值便可以记录每个页表的引用次数。同时使用<strong>自旋锁</strong>保证引用计数的互斥性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> cnt[PHYSTOP/PGSIZE];</span><br><span class="line">&#125; pgcnt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>kalloc</code>原本用于分配空闲页表，修改后额外将<code>cnt(引用计数)</code>设为1值</p><p><code>kfree</code>原本用于释放回收页表，修改后只有当<code>cnt(引用计数)</code>为1时才释放页表，其余情况下只需要将<code>cnt(引用计数)</code>减1即可。</p><p>额外增加3个函数，<code>addpgcnt(uint64 pa)</code>将物理内存<code>pa</code>的<code>cnt</code>值加1（该功能用于fork函数子进程共享父进程的物理内存），<code>cntpgcnt(uint64 pa)</code>返回物理内存<code>pa</code>的<code>cnt</code>值。</p><h3 id="4-虚拟地址合法范围"><a href="#4-虚拟地址合法范围" class="headerlink" title="4.虚拟地址合法范围"></a>4.虚拟地址合法范围</h3><p>在实际的代码编写过程中，我遇到了一个bug：</p><img src="/posts/e18dbd36/COW-BUG.gif" class="" title="COW-BUG"><p>这一<strong>BUG发生的原因</strong>经过排查后得到：在<a href="https://www.shui2000.top/posts/4fd45b61.html">Lab5_xv6LazyPageAllocation</a>实验中，为了满足<code>usertest</code>的要求，我在<code>usertrap</code>中加入了对发生错误的虚拟地址合法性检测。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;trapframe-&gt;sp&gt;failedva)&#123;</span><br><span class="line">      p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将虚拟地址发生在栈指针下的情况视为错误，终止了进程。并且成功通过了测验。</p><p>在本实验中我考虑到<code>COW</code>与<code>Lazy Allocation</code>都是利用<code>page fault</code>在中断处理函数<code>usertrap</code>中做文章,并且<code>scause</code>值都相同，皆为13或15，便直接将<code>Lazy Allocation</code>的这段检测代码复制了过来。</p><p>实际上：<code>Lazy Allocation</code>是对<strong>堆分配做出的优化</strong>，并且在之前的实验中并没有涉及对<code>fork</code>函数的修改，通过<code>fork</code>产生的子函数，<code>p-&gt;sz</code>值大于等于栈指针是必然的。所以<code>Lazy Allocation</code>假分配虚拟地址报错必然是高于栈指针。</p><p><code>COW</code>对<code>fork</code>函数进行了修改，在0-<code>p-&gt;sz</code>的范围内，子进程所有的物理内存都是共享自父进程。<strong>所以页面错误<code>(page fault)</code>可能发生在栈指针下</strong>，<strong>更详细的BUG分析在<a href="https://www.shui2000.top/posts/a33744ac.html">Lab6 init starting sh bug 原因分析</a>文章中。</strong></p><p>实际上虚拟地址的合法范围应该是<code>0~p-&gt;sz</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT6.S081 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> copy </tag>
            
            <tag> on </tag>
            
            <tag> write </tag>
            
            <tag> 写时复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081_2020_Lab6:init-starting-sh-bug-原因分析</title>
      <link href="/posts/a33744ac.html"/>
      <url>/posts/a33744ac.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、BUG的表现"><a href="#一、BUG的表现" class="headerlink" title="一、BUG的表现"></a>一、BUG的表现</h2><p>在Lab 6 实验中，遇见了这个现象</p><img src="/posts/a33744ac/COW-BUG.gif" class="" title="COW-BUG"><p>只要按下回车，就会输出<code>init: starting sh</code>,这个BUG看起来很有意思。</p><h2 id="二、结论"><a href="#二、结论" class="headerlink" title="二、结论"></a>二、结论</h2><p>先说结论:该BUG的产生原因：在之前<a href="https://www.shui2000.top/posts/4fd45b61.html">lab5 实验</a>时，<code>usertest</code>中存有一项测试<code>stacktest</code>报错：</p><img src="/posts/a33744ac/stacktest%E6%8A%A5%E9%94%99.png" class="" title="image-20240524205353066"><p><code>stacktest</code>源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usertests.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// check that there&#x27;s an invalid page beneath</span></span><br><span class="line"><span class="comment">// the user stack, to catch stack overflow.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">stacktest</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="type">int</span> xstatus;</span><br><span class="line">  </span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> *sp = (<span class="type">char</span> *) r_sp();</span><br><span class="line">    sp -= PGSIZE;</span><br><span class="line">    <span class="comment">// the *sp should cause a trap.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: stacktest: read below stack %p\n&quot;</span>, *sp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: fork failed\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait(&amp;xstatus);</span><br><span class="line">  <span class="keyword">if</span>(xstatus == <span class="number">-1</span>)  <span class="comment">// kernel killed child?</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exit</span>(xstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stacktest</code>这段代码是一个用于检测堆栈溢出的函数。在函数中，首先使用fork()创建一个子进程，然后在子进程中获取当前栈指针，减去页面大小（PGSIZE），并尝试读取这个地址的内容来引发一个异常(<code>trap</code>)(<strong>为什么会发生异常可以参考</strong>：<a href = '#stacktest'>stacktest</a>)。如果发生异常，子进程会返回1给父进程*(代码第15行：<code>exit(1)</code>)<em>，父进程等待子进程的返回值(<code>wait(&amp;xstatus)</code>)，<strong>如果返回值为-1,<code>stacktest</code>测试通过，否则测试失败。</strong>，返回值是-1的奥秘可以从注释中</em>(<code>kernel killed child?</code>)*看出,<strong>内核的中断处理函数应该检测到子进程的越界访问行为，并将子进程<code>kill</code>掉。</strong></p><p>所以在<a href="https://www.shui2000.top/posts/4fd45b61.html">lab5 实验</a>的<code>usertrap</code>函数中加入<span id = 'wrongcode'>一段代码</span>，检测发生<code>trap</code>的虚拟地址是否位于栈指针之下，如果是，将进程终止：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp) - <span class="number">1</span> &gt;= va )&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后测试<code>stacktest</code>成功：</p><img src="/posts/a33744ac/stacktest%E6%88%90%E5%8A%9F.png" class="" title="image-20240524210529587"><p><strong>Lab6实验紧跟着Lab5实验，同样需要借助异常处理机制，同样需要利用页面错误(<code>page fault</code>)，<code>scause</code>的值都为13或15，并且都需要通过<code>usertest</code>检测，所以自作聪明在Lab6<code>usertrap</code>代码中加入了这段代码导致的BUG发生：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp) - <span class="number">1</span> &gt;= va )&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>把这段代码去掉就可以了</strong></p><h3 id="为什么去掉这段代码可以通过stacktest"><a href="#为什么去掉这段代码可以通过stacktest" class="headerlink" title="为什么去掉这段代码可以通过stacktest?"></a>为什么去掉这段代码可以通过<code>stacktest</code>?</h3><p>相比于<code>Lazy allocation</code>实验，<code>copy on write</code>实验对权限检测的要求更加严格，以下代码保证正常运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(oldpte==<span class="number">0</span>|| (*oldpte &amp; PTE_V)==<span class="number">0</span> ||(*oldpte &amp; PTE_U)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//printf(&quot;pid=%d wrong access\n&quot;,p-&gt;pid );</span></span><br><span class="line">      p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三、探究BUG发生的过程"><a href="#三、探究BUG发生的过程" class="headerlink" title="三、探究BUG发生的过程"></a>三、探究BUG发生的过程</h2><h3 id="3-1有关函数提前梳理"><a href="#3-1有关函数提前梳理" class="headerlink" title="3.1有关函数提前梳理"></a>3.1有关函数提前梳理</h3><p><strong>由于每个人编写的Copy-On-Write的代码都不一样，本人的代码执行结果可能是独特的，并且最终的结果含有大量推测</strong></p><p><strong>由于每个人编写的Copy-On-Write的代码都不一样，本人的代码执行结果可能是独特的，并且最终的结果含有大量推测</strong></p><p><strong>由于每个人编写的Copy-On-Write的代码都不一样，本人的代码执行结果可能是独特的，并且最终的结果含有大量推测</strong></p><p>由于本BUG发生时现象过于神奇，即使问题已经得到了解决，我仍然决定详细跟踪研究，来探究该BUG发生的详细流程。</p><p>需要对Fork 函数，Exec函数，Wait函数，Exit函数的使用有所理解：</p><h4 id="3-1-1-Fork函数"><a href="#3-1-1-Fork函数" class="headerlink" title="3.1.1 Fork函数"></a>3.1.1 Fork函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">//printf(&quot;pid=%d use fork create pid=%d\n&quot;,p-&gt;pid,np-&gt;pid);</span></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fork会<strong>拷贝</strong>当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后，我们就有了两个拥有完全一样内存的进程。<strong>fork系统调用在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。</strong>所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。</p><h5 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="type">int</span> val=p-&gt;pid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;origin pid=%d\n&quot;</span>,val);</span><br><span class="line">    val=fork();</span><br><span class="line">    <span class="keyword">if</span>(val&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent val=%d\n&quot;</span>,val);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child val=%d\n&quot;</span>,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设原本进程的PID为2，那么该程序运行结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">origin pid= <span class="number">2</span></span><br><span class="line"><span class="comment">//因为多核的原因，后两行输出可能交替出现。</span></span><br><span class="line">parent val= <span class="number">3</span></span><br><span class="line">child val= <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-Exec-函数"><a href="#3-1-2-Exec-函数" class="headerlink" title="3.1.2 Exec 函数"></a>3.1.2 Exec 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG+<span class="number">1</span>], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="以下内容均复制自3-8-代码：exec"><a href="#以下内容均复制自3-8-代码：exec" class="headerlink" title="以下内容均复制自3.8 代码：exec"></a>以下内容均复制自<a href="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c3/s8.html">3.8 代码：exec</a></h5><p><code>exec</code>是创建地址空间的用户部分的系统调用。它使用一个存储在文件系统中的文件初始化地址空间的用户部分。</p><p><code>exec</code>(kernel&#x2F;exec.c:13)使用<code>namei</code> (kernel&#x2F;exec.c:26)打开指定的二进制<code>path</code>，这在第8章中有解释。然后，它读取ELF头。Xv6应用程序以广泛使用的ELF格式描述，定义于(kernel&#x2F;elf.h)。ELF二进制文件由ELF头、<code>struct elfhdr</code>(kernel&#x2F;elf.h:6)，后面一系列的程序节头（section headers）、<code>struct proghdr</code>(kernel&#x2F;elf.h:25)组成。每个<code>proghdr</code>描述程序中必须加载到内存中的一节（section）；xv6程序只有一个程序节头，但是其他系统对于指令和数据部分可能各有单独的节。</p><blockquote><p> Note</p><p><strong>ELF文件格式</strong>：在计算机科学中，是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。ELF是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且它们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p></blockquote><p>第一步是快速检查文件可能包含ELF二进制的文件。ELF二进制文件以四个字节的“幻数”<code>0x7F</code>、“<code>E</code>”、“<code>L</code>”、“<code>F</code>”或<code>ELF_MAGIC</code>开始(kernel&#x2F;elf.h:3)。如果ELF头有正确的幻数，<code>exec</code>假设二进制文件格式良好。</p><p><code>exec</code>使用<code>proc_pagetable</code> (kernel&#x2F;exec.c:38)分配一个没有用户映射的新页表，使用<code>uvmalloc</code> (kernel&#x2F;exec.c:52)为每个ELF段分配内存，并使用<code>loadseg</code> (kernel&#x2F;exec.c:10)将每个段加载到内存中。<code>loadseg</code>使用<code>walkaddr</code>找到分配内存的物理地址，在该地址写入ELF段的每一页，并使用<code>readi</code>从文件中读取。</p><p>使用<code>exec</code>创建的第一个用户程序<code>/init</code>的程序节标题如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objdump -p _init </span></span><br><span class="line">user/_init: file format elf64-littleriscv </span><br><span class="line">Program Header: </span><br><span class="line">    LOAD off 0x00000000000000b0 vaddr 0x0000000000000000 </span><br><span class="line">                                   paddr 0x0000000000000000 align 2**3 </span><br><span class="line">         filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx </span><br><span class="line">    STACK off 0x0000000000000000 vaddr 0x0000000000000000 </span><br><span class="line">                                   paddr 0x0000000000000000 align 2**4 </span><br><span class="line">         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-</span><br></pre></td></tr></table></figure><p>程序节头的<code>filesz</code>可能小于<code>memsz</code>，这表明它们之间的间隙应该用零来填充（对于C全局变量），而不是从文件中读取。对于&#x2F;init\，<code>filesz</code>是2112字节，<code>memsz</code>是2136字节，因此<code>uvmalloc</code>分配了足够的物理内存来保存2136字节，但只从文件&#x2F;init\中读取2112字节。</p><p>现在<code>exec</code>分配并初始化用户栈。<strong>它只分配一个栈页面</strong>。<code>exec</code>一次将参数中的一个字符串复制到栈顶，并在<code>ustack</code>中记录指向它们的指针。它在传递给<code>main</code>的<code>argv</code>列表的末尾放置一个空指针。<code>ustack</code>中的前三个条目是伪返回程序计数器（fake return program counter）、<code>argc</code>和<code>argv</code>指针。</p><p><span id = 'stacktest'><strong><code>exec</code>在栈页面的正下方放置了一个不可访问的页面，这样试图使用超过一个页面的程序就会出错。这个不可访问的页面还允许<code>exec</code>处理过大的参数</strong></span>；在这种情况下，被<code>exec</code>用来将参数复制到栈的函数<code>copyout</code>(kernel&#x2F;vm.c:355) 将会注意到目标页面不可访问，并返回-1。</p><p>在准备新内存映像的过程中，如果<code>exec</code>检测到像无效程序段这样的错误，它会跳到标签<code>bad</code>，释放新映像，并返回-1。<code>exec</code>必须等待系统调用会成功后再释放旧映像：因为如果旧映像消失了，系统调用将无法返回-1。<code>exec</code>中唯一的错误情况发生在映像的创建过程中。一旦映像完成，<code>exec</code>就可以提交到新的页表(kernel&#x2F;exec.c:113)并释放旧的页表(kernel&#x2F;exec.c:117)。</p><p><code>exec</code>将ELF文件中的字节加载到ELF文件指定地址的内存中。用户或进程可以将他们想要的任何地址放入ELF文件中。因此<code>exec</code>是有风险的，因为ELF文件中的地址可能会意外或故意的引用内核。对一个设计拙劣的内核来说，后果可能是一次崩溃，甚至是内核的隔离机制被恶意破坏（即安全漏洞）。xv6执行许多检查来避免这些风险。例如，<code>if(ph.vaddr + ph.memsz &lt; ph.vaddr)</code>检查总和是否溢出64位整数，危险在于用户可能会构造一个ELF二进制文件，其中的<code>ph.vaddr</code>指向用户选择的地址，而<code>ph.memsz</code>足够大，使总和溢出到0x1000，这看起来像是一个有效的值。在xv6的旧版本中，用户地址空间也包含内核（但在用户模式下不可读写），用户可以选择一个与内核内存相对应的地址，从而将ELF二进制文件中的数据复制到内核中。在xv6的RISC-V版本中，这是不可能的，因为内核有自己独立的页表；<code>loadseg</code>加载到进程的页表中，而不是内核的页表中。</p><p>内核开发人员很容易省略关键的检查，而现实世界中的内核有很长一段丢失检查的历史，用户程序可以利用这些检查的缺失来获得内核特权。xv6可能没有完成验证提供给内核的用户级数据的全部工作，恶意用户程序可以利用这些数据来绕过xv6的隔离。</p><hr><p>有关exec系统调用，有一些重要的事情，</p><ol><li>exec系统调用会<strong>保留当前的文件描述符表单</strong>。所以任何在exec系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。</li><li>通常来说exec系统调用不会返回，因为<strong>exec会完全替换当前进程的内存</strong>，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。</li></ol><h5 id="举个例子：-1"><a href="#举个例子：-1" class="headerlink" title="举个例子："></a>举个例子：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pid,status;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *argv[]=&#123;<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;THIS&quot;</span>,<span class="string">&quot;IS&quot;</span>,<span class="string">&quot;ECHO&quot;</span>,<span class="number">0</span>&#125;;<span class="comment">//0 标记了数组的结尾</span></span><br><span class="line">        exec(<span class="string">&quot;echo&quot;</span>,argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent waiting\n&quot;</span>);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the child exited with stauts %d\n&quot;</span>,status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，子进程使用exec函数执行了echo函数。<strong>如果exec执行成功，那么第7行与第8行的代码不会被执行。</strong>只有exec执行失败，这两行代码才会执行。<strong>但是exec执行成功后两个进程之间的父子关系并没有改变，exec执行后echo函数的代码的结尾依旧有exit(0)代码，所以父进程的<code>wait(&amp;status);</code>依旧可以获取子进程的退出状态</strong></p><h4 id="3-1-3-Exit函数与Wait函数"><a href="#3-1-3-Exit函数与Wait函数" class="headerlink" title="3.1.3 Exit函数与Wait函数"></a>3.1.3 Exit函数与Wait函数</h4><p><strong>Exit 与Wait函数通常用于父子进程之间传递参数。</strong></p><h5 id="Exit的源代码-代码中有个人分析-："><a href="#Exit的源代码-代码中有个人分析-：" class="headerlink" title="Exit的源代码(代码中有个人分析)："></a>Exit的源代码(代码中有个人分析)：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exit the current process.  Does not return.</span></span><br><span class="line"><span class="comment">// An exited process remains in the zombie state</span></span><br><span class="line"><span class="comment">// until its parent calls wait().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;exit proc pid is =%d\n&quot;</span>,p-&gt;pid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;exit proc parent pid is =%d\n&quot;</span>,p-&gt;parent-&gt;pid);</span><br><span class="line">  <span class="comment">//exit不能退出初始进程，会报错</span></span><br><span class="line">  <span class="keyword">if</span>(p == initproc)</span><br><span class="line">    panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close all open files.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd])&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">      fileclose(f);</span><br><span class="line">      p-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//日志相关操作,防止断电等意外</span></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(p-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  p-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we might re-parent a child to init. we can&#x27;t be precise about</span></span><br><span class="line">  <span class="comment">// waking up init, since we can&#x27;t acquire its lock once we&#x27;ve</span></span><br><span class="line">  <span class="comment">// acquired any other proc lock. so wake up init whether that&#x27;s</span></span><br><span class="line">  <span class="comment">// necessary or not. init may miss this wakeup, but that seems</span></span><br><span class="line">  <span class="comment">// harmless.</span></span><br><span class="line">  acquire(&amp;initproc-&gt;lock);</span><br><span class="line">  wakeup1(initproc);</span><br><span class="line">  release(&amp;initproc-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// grab a copy of p-&gt;parent, to ensure that we unlock the same</span></span><br><span class="line">  <span class="comment">// parent we locked. in case our parent gives us away to init while</span></span><br><span class="line">  <span class="comment">// we&#x27;re waiting for the parent lock. we may then race with an</span></span><br><span class="line">  <span class="comment">// exiting parent, but the result will be a harmless spurious wakeup</span></span><br><span class="line">  <span class="comment">// to a dead or wrong process; proc structs are never re-allocated</span></span><br><span class="line">  <span class="comment">// as anything else.</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">original_parent</span> =</span> p-&gt;parent;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we need the parent&#x27;s lock in order to wake it up from wait().</span></span><br><span class="line">  <span class="comment">// the parent-then-child rule says we have to lock it first.</span></span><br><span class="line">  acquire(&amp;original_parent-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  wakeup1(original_parent);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  release(&amp;original_parent-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Exit</code>（*<strong>kernel&#x2F;proc.c*</strong>:333）记录退出状态码(status)，释放一些资源，<span id ='exit'> **将所有子进程提供给<code>init</code>进程 **  </span>，在父进程处于等待状态时唤醒父进程，将调用方标记为僵尸进程（zombie），并永久地让出CPU。最后的顺序有点棘手。退出进程必须在将其状态设置为<code>ZOMBIE</code>并唤醒父进程时持有其父进程的锁，因为父进程的锁是防止在<code>wait</code>中丢失唤醒的条件锁。子级还必须持有自己的<code>p-&gt;lock</code>，否则父级可能会看到它处于<code>ZOMBIE</code>状态，并在它仍运行时释放它。锁获取顺序对于避免死锁很重要：因为<code>wait</code>先获取父锁再获取子锁，所以<code>exit</code>必须使用相同的顺序。</p><p><code>Exit</code>调用一个专门的唤醒函数<code>wakeup1</code>，该函数仅唤醒父进程，且父进程必须正在<code>wait</code>中休眠（*<strong>kernel&#x2F;proc.c*</strong>:598）。在将自身状态设置为<code>ZOMBIE</code>之前，子进程唤醒父进程可能看起来不正确，但这是安全的：虽然<code>wakeup1</code>可能会导致父进程运行，但<code>wait</code>中的循环在<code>scheduler</code>释放子进程的<code>p-&gt;lock</code>之前无法检查子进程，所以<code>wait</code>在<code>exit</code>将其状态设置为<code>ZOMBIE</code>（kernel&#x2F;proc.c:386）之前不能查看退出进程。</p><blockquote><p>回答来自chatgpt</p><p>1.Linux 在杀死一个进程时为什么要让子进程重新设置父进程？</p><p>Linux 在杀死一个进程时需要让子进程重新设置父进程是为了确保子进程不会成为孤儿进程。当父进程被终止时，操作系统会将孤儿进程的新父进程设置为 init 进程（PID 为 1 的进程），这样可以确保孤儿进程仍然能够被正确地回收和管理。因此，在杀死一个进程时，需要让子进程重新设置父进程，以避免产生孤儿进程。</p><p>2.为什么要唤醒父进程？</p><p>在Linux中，当一个子进程终止时，通常会向其父进程发送一个 SIGCHLD 信号。父进程通常会通过调用 wait() 系统调用来等待和处理子进程的终止状态。这样做可以确保父进程能够及时得知子进程的退出状态，以便进行适当的清理和处理。</p><p>因此，在杀死一个进程时，需要唤醒父进程，使其有机会处理子进程的终止状态，并采取必要的操作，比如回收资源或记录日志等。这种通信机制可以确保进程间的协同工作和资源管理。</p></blockquote><h5 id="Wait函数的源代码"><a href="#Wait函数的源代码" class="headerlink" title="Wait函数的源代码"></a>Wait函数的源代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for a child process to exit and return its pid.</span></span><br><span class="line"><span class="comment">// Return -1 if this process has no children.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hold p-&gt;lock for the whole time to avoid lost</span></span><br><span class="line">  <span class="comment">// wakeups from a child&#x27;s exit().</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">      <span class="comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span></span><br><span class="line">      <span class="comment">// acquiring the lock first would cause a deadlock,</span></span><br><span class="line">      <span class="comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span></span><br><span class="line">      <span class="keyword">if</span>(np-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">        <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">        acquire(&amp;np-&gt;lock);</span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = np-&gt;pid;</span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;np-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;np-&gt;lock);</span><br><span class="line">            release(&amp;p-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(np);</span><br><span class="line">          release(&amp;np-&gt;lock);</span><br><span class="line">          release(&amp;p-&gt;lock);</span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || p-&gt;killed)&#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    sleep(p, &amp;p-&gt;lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父进程调用Wait函数等待子进程的退出。Wait函数会<strong>死循环(:14)扫描进程表直到发现子进程(:21)</strong></p><p><strong><code>wait(&amp;state)</code>函数返回退出的的子进程的PID号，并将退出的状态标志保存在<code>state</code>中</strong>,如果一个父进程拥有多个子进程，wait(0)只能检测到一个子进程的退出，要检测其他子进程的退出状态，父进程需要调用 wait函数多次，或者使用循环来处理所有子进程的退出状态。</p><h4 id="3-1-4-Initcode-PID-x3D-1-的进程"><a href="#3-1-4-Initcode-PID-x3D-1-的进程" class="headerlink" title="3.1.4 Initcode,PID&#x3D;1 的进程"></a>3.1.4 <code>Initcode</code>,PID&#x3D;1 的进程</h4> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[] = &#123; <span class="string">&quot;sh&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line">  <span class="comment">//文件描述符设置</span></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line">  <span class="comment">//第一层死循环</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    <span class="comment">//这里的pid为新建shell进程的pid号，而非initcode的pid号</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程运行shell程序</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//父进程运行第二层死循环，等待任一子进程返回</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the shell exited; restart it.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>initcode</code>函数作为XV6操作系统中用户级别第一个进程<code>(PID=1)</code>，其主要作用是保证<code>shell</code>进程存在.</strong></p><p>注意：<code>initcode</code>函数大部分时间运行在第二层死循环中<code>c:30-43</code>，<strong>由于操作系统运行过程中肯定会杀死不少进程，而进程被杀死时，其子进程的父进程会被设置为<code>initcode</code></strong> <a href = '#exit' >（原因）</a>，所以<code>wpid</code>得到的不一定是<code>shell</code>程序的<code>pid</code>号，需要<code>if</code>条件句进行判断。</p><p>当判断出来<code>shell</code>进程停止运行了，<code>initcode</code>需要重新运行<code>shell</code>程序。</p><h4 id="3-1-5-shell程序"><a href="#3-1-5-shell程序" class="headerlink" title="3.1.5 shell程序"></a>3.1.5 <code>shell</code>程序</h4><p>shell程序的代码比较多，先贴出来<code>main</code>函数代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line">  <span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    panic(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c:16</code>之前为文件描述符的相关设置，之后为<code>shell</code>程序的逻辑关键，可以看出：</p><p><strong>每次循环<code>shell</code>程序从缓冲区<code>buf</code>中读取指令<code>c:16</code>,使用<code>fork</code>函数，生成一个子进程，子进程执行指令，<code>shell</code>程序自身等待子进程的结束后进入下一次循环。正常情况下,<code>shell</code>程序一直处于循环之中，不会中止。</strong>可以在未曾修改过代码的XV6系统中(也就是说，initcode，与shell程序都正常运转)，修改<code>fork</code>函数，输出父进程与子进程的<code>pid</code>号;可以看到输出结果符合预期：</p><img src="/posts/a33744ac/%E4%BF%AE%E6%94%B9fork%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BE%93%E5%87%BA%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84pid%E5%8F%B7.png" class="" title="image-20240525183216789"><hr><h3 id="3-2正式开始分析BUG"><a href="#3-2正式开始分析BUG" class="headerlink" title="3.2正式开始分析BUG"></a>3.2正式开始分析BUG</h3><h4 id="3-2-1-到底发生了什么？"><a href="#3-2-1-到底发生了什么？" class="headerlink" title="3.2.1 到底发生了什么？"></a>3.2.1 到底发生了什么？</h4><p><strong>将发生BUG的代码，进行修改，</strong>让<code>fork</code>函数执行时，输出父进程与子进程的<code>pid</code>号;同时在中断处理函数中的<a href = '#wrongcode'>错误代码</a>进行修改，在杀死进程前输出被杀死进程的<code>pid</code>号;<code>initcode</code>第一层循环开始是输出<code>----------------------------</code>,最终输出结果如下：</p><img src="/posts/a33744ac/%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99.png" class="" title="image-20240525175200126"><p><strong>从图中可以看出，<code>shell</code>进程<code>fork</code>出的子进程在BUG发生后终止了运行，shell程序紧接着也停止了运行。<code>initcode</code>检测到了<code>shell</code>程序的中止，重新启动<code>shell</code>并输出：<code>init: starting sh</code></strong></p><h4 id="3-2-2-shell进程在哪里发生了错误？"><a href="#3-2-2-shell进程在哪里发生了错误？" class="headerlink" title="3.2.2 shell进程在哪里发生了错误？"></a>3.2.2 <code>shell</code>进程在哪里发生了错误？</h4><p>通过广泛使用<code>printf</code>函数，与GDB调试工具，来定位BUG产生的地区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为 shell程序增加了大量的printf</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line">  <span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin loop\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end loop\n&quot;</span>);   </span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/a33744ac/%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%992.png" class="" title="image-20240525185443362"><p>分析结果，主要的问题是 <code>while(getcmd(buf, sizeof(buf)) &gt;= 0)</code> <strong>这段代码，就如同BUG的现象一样奇特，这段代码在<code>shell</code>程序第一次读取指令时不会报错，而第二次读取指令时会报错。</strong></p><p>为出错的<code>getcmd</code>函数增加<code>printf</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;getcmd begin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;memset finish\n&quot;</span>);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gets finish\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><img src="/posts/a33744ac/%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%993.png" class="" title="image-20240525185640094"><p><strong>最终定位到<code>memset(buf, 0, nbuf);</code>这段代码，这段代码第一次执行没有问题，第二次执行会报错。</strong></p><p>查看<code>memset</code>的源代码,无法提供太多有用的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> c, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *cdst = (<span class="type">char</span> *) dst;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    cdst[i] = c;<span class="comment">//实际报错的地方</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="shell-fork后的子进程cow发生在哪"><a href="#shell-fork后的子进程cow发生在哪" class="headerlink" title="shell fork后的子进程cow发生在哪"></a><code>shell</code> <code>fork</code>后的子进程<code>cow</code>发生在哪</h5><p>通过寻找<code>shell</code>开始崩溃的代码方法一样，最终发现子进程发生错误的指令位于:<code>main-&gt;runcmd(parsecmd(buf))-&gt;parsecmd(buf)-&gt;parseline(&amp;s, es)-&gt;parsepipe(ps, es)-&gt;parseexec(ps, es)-&gt;execcmd()-&gt;malloc(sizeof(*cmd))</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">malloc</span><span class="params">(uint nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">  Header *p, *prevp;</span><br><span class="line">  uint nunits;  </span><br><span class="line">  nunits = (nbytes + <span class="keyword">sizeof</span>(Header) - <span class="number">1</span>)/<span class="keyword">sizeof</span>(Header) + <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">if</span>((prevp = freep) == <span class="number">0</span>)&#123;</span><br><span class="line">    base.s.ptr = freep = prevp = &amp;base;<span class="comment">//实际报错的地方。</span></span><br><span class="line">    base.s.size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;s.size &gt;= nunits)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;s.size == nunits)</span><br><span class="line">        prevp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;s.size -= nunits;</span><br><span class="line">        p += p-&gt;s.size;</span><br><span class="line">        p-&gt;s.size = nunits;</span><br><span class="line">      &#125;</span><br><span class="line">      freep = prevp;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">void</span>*)(p + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == freep)</span><br><span class="line">      <span class="keyword">if</span>((p = morecore(nunits)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>malloc</code>与<code>memset</code>都为高频使用的函数，这两个代码出错的可能性极低，我更愿意相信是之前的地方存在逻辑错误，只是到了这里爆发了出来</strong></p><h4 id="3-2-3-内核中发生了什么"><a href="#3-2-3-内核中发生了什么" class="headerlink" title="3.2.3 内核中发生了什么?"></a>3.2.3 内核中发生了什么?</h4><p>在<code>usertrap</code>中<strong>增加更多的printf代码</strong>，当发生<code>cow</code>错误后输出”cow\n”:</p><p>此图为有BUG的输出结果：</p><img src="/posts/a33744ac/%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%994.png" class="" title="image-20240525192945858"><p>此图为正常运行的数据结果：</p><img src="/posts/a33744ac/%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C.png" class="" title="image-20240525200431737"><p>对比可以看出：</p><p>1.<code>initcode</code> <code>fork</code>出来<code>shell</code>程序时并没有发生<code>cow</code></p><p>2.<code>shell</code>程序<code>fork</code>并执行<code>cmd</code>时发生了三次<code>cow</code>,第二次<code>cow</code>导致了子进程的崩溃， 第三次<code>cow</code>导致<code>shell</code>程序的崩溃，而之前我们发现报错的直接原因是<code>memset</code>与<code>malloc</code>这两个高频使用的函数。</p><h3 id="3-3-以下皆为推论"><a href="#3-3-以下皆为推论" class="headerlink" title="3.3 以下皆为推论"></a>3.3 以下皆为推论</h3><img src="/posts/a33744ac/%E6%94%BE%E5%BC%83.png" class="" title="image-20240525204530976"><p><code>Fork</code>函数后面常常跟<code>exec</code>函数，该函数的一大特点便是<strong>完全替换当前进程的内存</strong>，所以将栈指针下方皆视为非法地址，在遇到<code>exec</code>函数的情况下，即使不当场报错，也可能对后续的函数产生不良影响。同时，部分进程需要对局部变量进行修改，而局部变量就位于栈指针下，随便从其他实验借来的代码没有考虑到这些情况导致BUG的发生。</p><p>原本我预期可以清楚地分析出BUG的所在，但是整个过程相比于自己平时手搓的代码DEBUG还是太复杂了，最终只是推论解释这个BUG。但是为了解决这个BUG，我仍进行了相当长时间的思考，我认为<strong>即使结果没有达到预期，我中间的思维过程也不会白白浪费掉，所以我决定将思路记录下来。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT6.S081 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 写时复制 </tag>
            
            <tag> fork </tag>
            
            <tag> 内核 </tag>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081_2020_Lab5:LazyPageAllocation</title>
      <link href="/posts/4fd45b61.html"/>
      <url>/posts/4fd45b61.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是惰性分配（lazy-page-allocation）？"><a href="#一、什么是惰性分配（lazy-page-allocation）？" class="headerlink" title="一、什么是惰性分配（lazy page allocation）？"></a>一、什么是惰性分配（<code>lazy page allocation</code>）？</h2><h3 id="1-eager-allocation"><a href="#1-eager-allocation" class="headerlink" title="1.eager allocation"></a>1.<code>eager allocation</code></h3><p><code>sbrk</code>是xv6提供的系统调用，使得用户应用程序能扩大自己的<code>heap</code>。<strong>当一个应用程序启动的时候，<code>PAGESIZE</code>为<code>heap</code>的最底端，同时也是<code>stack</code>的最顶端。这个位置通过代表进程的数据结构中的<code>sz</code>字段表示，这里以*<code>p-&gt;sz</code>表示*。</strong></p><img src="/posts/4fd45b61/%E6%83%B0%E6%80%A7%E5%88%86%E9%85%8D.png" class="" title="image-20240422220806810"><p>当调用<code>sbrk</code>时，它的参数是整数，代表了你想要申请的字节数.</p><p>这意味着，当<code>sbrk</code>实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为0，再返回<code>sbrk</code>系统调用。这样，应用程序可以通过多次<code>sbrk</code>系统调用来增加它所需要的内存。类似的，应用程序还可以通过给<code>sbrk</code>传入负数作为参数，来减少或者压缩它的地址空间。</p><p>在XV6中，**<code>sbrk</code>的实现默认是<code>eager allocation</code><strong>。这表示了，一旦调用了<code>sbrk</code>，内核会</strong>立即分配**应用程序所需要的物理内存。但是实际上，对于应用程序来说很难预测自己需要多少内存，所以通常来说，应用程序倾向于申请多于自己所需要的内存。这意味着，进程的内存消耗会增加许多，但是有部分内存永远也不会被应用程序所使用到。</p><h3 id="2-lazy-allocation的核心思想"><a href="#2-lazy-allocation的核心思想" class="headerlink" title="2.lazy allocation的核心思想"></a>2.<code>lazy allocation</code>的核心思想</h3><p><code>lazy allocation</code>核心思想非常简单，<code>sbrk</code>系统调基本上不做任何事情，唯一需要做的事情就是提升<code>p-&gt;sz</code>，将<code>p-&gt;sz</code>增加<code>n</code>，其中<code>n</code>是需要新分配的字节数。但是内核在这个时间点<strong>并不会分配任何物理内存</strong>。之后在某个时间点，应用程序使用到了新申请的那部分内存，这时会触发<code>page fault</code>，因为我们还没有将新的内存映射到<code>page table</code>。所以，如果我们解析一个大于旧的<code>p-&gt;sz</code>，但是又小于新的<code>p-&gt;sz</code>（注，也就是旧的<code>p-&gt;sz + n</code>）的虚拟地址，我们希望内核能够分配一个内存<code>page</code>，并且重新执行指令。</p><p>所以，当我们看到了一个<code>page fault</code>，相应的虚拟地址小于当前<code>p-&gt;sz</code>，同时大于<code>stack</code>，那么我们就知道这是一个来自于<code>heap</code>的地址，但是内核还没有分配任何物理内存。所以对于这个<code>page fault</code>的响应也理所当然的直接明了：在<code>page fault handler</code>中，通过<code>kalloc</code>函数分配一个内存<code>page</code>；初始化这个<code>page</code>内容为0；将这个内存<code>page</code>映射到<code>user page table</code>中；最后重新执行指令。比方说，如果是<code>load</code>指令，或者<code>store</code>指令要访问属于当前进程但是还未被分配的内存，在我们映射完新申请的物理内存page之后，重新执行指令应该就能通过了。</p><h2 id="二、如何实现lazy-allocation"><a href="#二、如何实现lazy-allocation" class="headerlink" title="二、如何实现lazy allocation?"></a>二、如何实现<code>lazy allocation</code>?</h2><p><code>lazy allocation</code>的核心思想简单易懂，我们根据思想对<code>sbrk</code>函数进行修改即可.<strong>注意：<code>sbrk</code>函数不仅用于增加物理内存，也用于减少物理内存</strong></p><h3 id="1-先分析sbrk函数原本的功能，再做修改"><a href="#1-先分析sbrk函数原本的功能，再做修改" class="headerlink" title="1.先分析sbrk函数原本的功能，再做修改"></a>1.先分析<code>sbrk</code>函数原本的功能，再做修改</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">//n为想要增加或减少的字节数</span></span><br><span class="line">  <span class="comment">//addr为p-&gt;sz 所指的地址</span></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//立马分配n个字节给进程(eager allocation)</span></span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//减少字节数</span></span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来<code>sbrk</code>函数原本根据n的正负值来立刻分配或立刻减少n个字节给进程</p><p>根据<code>lazy allcation</code>的思想，我们在进程要求新增物理内存大小的时候只增加<code>p-&gt;sz</code>的值，如何操作看下一节，我们还需要思考，**<code>lazy allocation</code>的思想是否可以用于减少物理内存的大小？**</p><p>答案是不可以：因为我们是通过<code>page fault</code>会进入<code>usertrap</code>函数这一机制，在进程实际需要使用到内存的时候为其分配物理内存。</p><p>倘若n值为复数，<strong>我们仅仅将<code>p-sz</code>的值减少而不去释放物理内存，那么当进程访问本不应该存在的物理地址时，不会发生<code>page fault</code>，</strong></p><p><strong>进而程序使用了本不应该使用的物理内存，而操作系统却没有报错。</strong>所以我们对n值为负数时，立刻释放物理内存的操作不做修改。</p><p>修改后的<code>sbrk</code>函数如下(为了避免对<code>growproc</code>函数的修改，将n值正负如何进行处理的代码选择放在了<code>sbrk</code>函数中)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  uint64 sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// lazy allocation 仅增加p-&gt;sz的大小，并不实际分配物理内存</span></span><br><span class="line">    p-&gt;sz += n;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sz + n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 减少n字节</span></span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    p-&gt;sz = sz;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 减少n字节，p-sz 大小小于0，说明减少的字节太多，发生错误。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在usertrap中增加对page-fault的处理"><a href="#2-在usertrap中增加对page-fault的处理" class="headerlink" title="2.在usertrap中增加对page fault的处理"></a>2.在<code>usertrap</code>中增加对<code>page fault</code>的处理</h3><h4 id="2-1-trap流程与systemcall调用流程的区别"><a href="#2-1-trap流程与systemcall调用流程的区别" class="headerlink" title="2.1 trap流程与systemcall调用流程的区别"></a>2.1 <code>trap</code>流程与<code>systemcall</code>调用流程的区别</h4><p>这里的 <code>trap</code>流程与<code>systemcall</code>类似，不同于<code>systemcall</code>的是，在进入内核态后，<code>r_scause()</code>值不同，原本的</p><img src="/posts/4fd45b61/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7.png" class="" title="image-20240506213106166"><p>xv6系统，虽然<code>scause</code>会根据不同的<code>trap</code>赋予不同的值，但实际上的<code>usertrap</code>函数中只有处理<code>scause</code>值为8（系统调用）的代码，我们需要在<code>usertrap</code>函数中自行添加对<code>page fault</code>的处理。</p><p>我们可以根据图片看出来<code>xv6</code>系统会根据不同的<code>page fault</code>生成三种不同的数值：12(因为指令执行引起的<code>page fault</code>)、13(因为load–读操作引起的<code>page fault</code>)、15(是因为store–写操作引起的<code>page fault</code>)</p><p>由于本身的xv6系统不存在实际上的<code>scause</code>为其他值的情况，我们<strong>可以认为所有<code>scause</code>值为其他值的情况都是由于我们的修改引起的</strong>。我们可以用<code>print</code>函数将<code>scause</code>值打印出来调试错误，实际上后续的实验过程中，由于<code>lazy allocation</code>引起的<code>scause</code>只有13或15两种值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// system call    </span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    ...  </span><br><span class="line">      </span><br><span class="line">  &#125; <span class="comment">//page fault</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>||r_scause() == <span class="number">13</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  &#125; </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-发生page-fault的虚拟地址范围"><a href="#2-2-发生page-fault的虚拟地址范围" class="headerlink" title="2.2 发生page fault的虚拟地址范围"></a>2.2 发生<code>page fault</code>的虚拟地址范围</h4><p>这样我们在<code>usertrap</code>函数中可以通过<code>r_stval</code>得知发生<code>page fault</code>的虚拟地址</p><p><code>xv6</code>中虚拟地址的范围在<code>0-MAXVA</code>之间，所以超出这个范围的<code>sepc</code>值属于严重的错误，我们应该将进程杀死，而不是对待<code>page fault</code>的方式对其进行处理。<code>lazy allocation</code>政策下发生<code>page fault</code>的情况是错以为有内存的情况下进行读写操作，所以<strong>发生<code>page fault</code>的虚拟地址应该小于进程认为自己拥有的字节大小（<code>p-&gt;sz</code>）</strong></p><p>其次，目前的<code>lazy allocation</code>仅在需要增加字节的时候使用，所以<strong>发生<code>page fault</code>的虚拟地址应该大于栈指针</strong>（<code>p-&gt;trapframe-&gt;sp</code>）<em>（xv6最初的进程为栈分配了PGSIZE的值，后续的进程都是初始进程fork出来的，意味着所有进程都具有PGSIZE大小的栈，那么我们<code>lazy allocation</code>的地址一定是大于栈指针的）</em>。</p><p>所以，<strong>综合考虑下</strong>我们检测发生<code>page fault</code>的范围应该是<code>p-&gt;trapframe-&gt;sp   -   p-&gt;sz</code></p><h4 id="2-3-分配物理内存并进行映射"><a href="#2-3-分配物理内存并进行映射" class="headerlink" title="2.3 分配物理内存并进行映射"></a>2.3 分配物理内存并进行映射</h4><p>在判断发生虚拟地址的正确性后，我们需要做的就是为其分配物理地址并映射，应该注意的是当物理内存不足后，我们直接杀死了进程。其余更高级的系统会采用更加灵活的方式：</p><p>最终的代码应该是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/trap.c/usertrap函数中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>||r_scause() == <span class="number">13</span>)&#123;<span class="comment">//page fault</span></span><br><span class="line">    <span class="comment">// printf(&quot;it is page fault\n&quot;);</span></span><br><span class="line">    <span class="comment">// printf(&quot;usertrap(): unexpected scause %p pid=%d\n&quot;, r_scause(), p-&gt;pid);</span></span><br><span class="line">    <span class="comment">// printf(&quot;            sepc=%p stval=%p\n&quot;, r_sepc(), r_stval());</span></span><br><span class="line">    <span class="comment">//stval寄存器中保存了造成页面错误的虚拟地址</span></span><br><span class="line">    uint64 va=r_stval();</span><br><span class="line">    <span class="comment">//如果某个进程在高于sbrk()分配的任何虚拟内存地址上出现页错误，则终止该进程。</span></span><br><span class="line">    <span class="comment">//page guard</span></span><br><span class="line">    <span class="keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp) - <span class="number">1</span> &gt;= va )&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(va&gt;p-&gt;sz)&#123;</span><br><span class="line">      p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      uint64* ka=kalloc();</span><br><span class="line">      <span class="keyword">if</span>(ka==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;out of memory\n&quot;);</span></span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//填空垃圾数据</span></span><br><span class="line">          <span class="built_in">memset</span>((<span class="type">void</span> *)ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">          <span class="keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)ka, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">            kfree((<span class="type">void</span> *)ka);</span><br><span class="line">            p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="三、惰性分配一定优于积极分配-eager-allocation-吗？"><a href="#三、惰性分配一定优于积极分配-eager-allocation-吗？" class="headerlink" title="三、惰性分配一定优于积极分配(eager allocation)吗？"></a>三、惰性分配一定优于积极分配<code>(eager allocation)</code>吗？</h2><p>​惰性分配策略并不一定优于积极分配策略。两种策略各有优缺点，适用于不同的场景和需求。积极分配策略直接为进程分配内存，简单直接，适合对内存需求较为明确的情况，可以提高系统的响应速度。而惰性分配策略则可以节省内存资源，只在实际需要时进行分配，适用于内存需求不确定或者资源有限的情况下，可以降低内存的浪费。因此，选择哪种分配策略取决于具体的应用场景和需求，没有一种策略绝对优于另一种策略。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT6.S081 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> page </tag>
            
            <tag> 地址映射 </tag>
            
            <tag> lazy </tag>
            
            <tag> allocation </tag>
            
            <tag> 惰性分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081中Systemcall的调用流程</title>
      <link href="/posts/932c8df1.html"/>
      <url>/posts/932c8df1.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MIT6.S081 项目中的许多实验都涉及到了系统调用（System Call）的使用，我在实验过程中往往依葫芦画瓢在原有的System Call基础上使用，没有真正理解System Call的流程，本篇笔记打算<strong>以<code>sys_sleep</code>为例子</strong>梳理一下Xv6系统中 System Call的调用流程。</p><h2 id="一、用户态（-x2F-user-x2F-）中的系统调用"><a href="#一、用户态（-x2F-user-x2F-）中的系统调用" class="headerlink" title="一、用户态（&#x2F;user&#x2F;）中的系统调用"></a>一、用户态（&#x2F;user&#x2F;）中的系统调用</h2><p>我们可以在<code>/user/user.h</code>中找到sleep函数的函数声明，却<strong>无法找到sleep函数的函数定义</strong>。</p><p>实际上我们可以在<code>user/usys.pl</code>中找到<strong>除了函数调用以外sleep函数的出现</strong>,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">#!/usr/bin/perl -w</span><br><span class="line"></span><br><span class="line"># Generate usys.S, the stubs <span class="keyword">for</span> syscalls.</span><br><span class="line"></span><br><span class="line">print <span class="string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">print <span class="string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">....</span><br><span class="line"><span class="comment">//剩余代码都是entry(&quot;system call&quot;)的格式，故省略</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 代码含义解释来自于chatgpt3.5</span></span><br><span class="line"><span class="comment">这段代码是用 Perl 编写的脚本，用于生成 `usys.S` 文件，其中包含系统调用的存根（stubs）。我来解释一下代码的含义：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. `#!/usr/bin/perl -w`：这是脚本的 shebang 行，指示系统使用 Perl 解释器执行该脚本。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. `print &quot;# generated by usys.pl - do not edit\n&quot;;`：打印一条注释，说明该文件是由 `usys.pl` 生成的，不应手动编辑。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. `print &quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;;`：打印 `#include` 指令，将 `kernel/syscall.h` 文件包含进来，该文件可能包含了系统调用的相关定义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. `sub entry &#123; ... &#125;`：定义了一个名为 `entry` 的子例程，用于生成系统调用的存根。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 在 `entry` 子例程中，对于每个传入的系统调用名，都生成了相应的存根。这些存根包括以下几个步骤：</span></span><br><span class="line"><span class="comment">   - `.global $name`：将该系统调用名声明为全局符号。</span></span><br><span class="line"><span class="comment">   - `$&#123;name&#125;:`：定义一个标签，表示系统调用的起始点。</span></span><br><span class="line"><span class="comment">   - `li a7, SYS_$&#123;name&#125;`：将系统调用号加载到寄存器 a7 中。这里假设 `SYS_$&#123;name&#125;` 是一个宏，用于获取该系统调用的编号。</span></span><br><span class="line"><span class="comment">   - `ecall`：触发系统调用。</span></span><br><span class="line"><span class="comment">   - `ret`：返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. 最后，对于每个系统调用，都调用了 `entry` 子例程，传入相应的系统调用名，以生成相应的存根。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">总体来说，这段代码的作用是生成一系列系统调用的存根，这些存根可以用于在特定的环境中进行系统调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、生成的usys-S文件中的汇编语言"><a href="#二、生成的usys-S文件中的汇编语言" class="headerlink" title="二、生成的usys.S文件中的汇编语言"></a>二、生成的usys.S文件中的汇编语言</h2><p>通过<code>user/usys.pl</code>的代码我们可以推测其为每一个系统调用（System Call）都进行了entry操作，生成到了<code>user/usys.S</code>文件中,该文件<strong>每个系统调用都对应三行汇编语言</strong>，我只复制了与sleep相关的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># generated by usys.pl - do not edit</span><br><span class="line">#include &quot;kernel/syscall.h&quot;</span><br><span class="line">.global sleep</span><br><span class="line">sleep:</span><br><span class="line"> li a7, SYS_sleep</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p><code>#include &quot;kernel/syscall.h&quot;</code>代表汇编文件前插入了<code>kernel/syscall.h</code>，我们在遇到不懂的内容时，应该去该文件查看寻找问题的答案。</p><h3 id="1-li-a7-SYS-sleep"><a href="#1-li-a7-SYS-sleep" class="headerlink" title="1.li a7, SYS_sleep"></a>1.li a7, SYS_sleep</h3><p>这行代码的含义是将系统调用号 <code>SYS_sleep</code> 加载到寄存器 <code>a7</code> 中。<strong>在 RISC-V 架构中，寄存器 <code>a7</code> 通常被用作系统调用号的参数寄存器。</strong>因此，这行代码的目的是将 <code>SYS_sleep</code> 这个系统调用的编号加载到 <code>a7</code> 寄存器，以便在调用系统调用时使用。</p><p><code>SYS_sleep</code>的值可以在<code>kernel/syscall.h</code>中找到,为13。该文件给每一个system call都对应了一个数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#define SYS_sbrk   12</span><br><span class="line">#define SYS_sleep  13</span><br><span class="line">#define SYS_uptime 14</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-ecall（该指令为CPU指令）"><a href="#2-ecall（该指令为CPU指令）" class="headerlink" title="2.ecall（该指令为CPU指令）"></a>2.ecall（该指令为CPU指令）</h3><p>在<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec06-isolation-and-system-call-entry-exit-robert">Lec06 Isolation &amp; system call entry&#x2F;exit (Robert)</a>课程中我们可以学习到ecall指令的作用（ecall内容的笔记基本摘抄自课程翻译，不理解可以去看原课程）：</p><h4 id="2-1-ecall将代码从user-mode改到supervisor-mode"><a href="#2-1-ecall将代码从user-mode改到supervisor-mode" class="headerlink" title="2.1 ecall将代码从user mode改到supervisor mode"></a>2.1 <code>ecall</code>将代码从<code>user mode</code>改到<code>supervisor mode</code></h4><p>注意:作为代码编写者的我们并<strong>没有办法能直接分辨</strong>系统处于user mode还是supervisor mode，下图为PTE结构，Flag中存在标志位U，xv6系统标志位U为1的时候，只有user mode下能访问而supervisor mode不能访问，我们通过这个方法来间接分辨系统处于什么状态。</p><img src="/posts/932c8df1/PTE%E7%BB%93%E6%9E%84.png" class="" title="image-20240421180742156"><h4 id="2-2-ecall将程序计数器的值保存在了SEPC寄存器"><a href="#2-2-ecall将程序计数器的值保存在了SEPC寄存器" class="headerlink" title="2.2 ecall将程序计数器的值保存在了SEPC寄存器"></a>2.2 <code>ecall</code>将程序计数器的值保存在了<code>SEPC</code>寄存器</h4><p>SEPC寄存器保存的值将在 <code>supervisor mode</code> 返回至 <code>user mode</code>时发挥作用</p><h4 id="2-3-ecall会跳转到STVEC寄存器指向的指令（uservec函数）"><a href="#2-3-ecall会跳转到STVEC寄存器指向的指令（uservec函数）" class="headerlink" title="2.3 ecall会跳转到STVEC寄存器指向的指令（uservec函数）"></a>2.3 <code>ecall</code>会跳转到<code>STVEC</code>寄存器指向的指令（uservec函数）</h4><p>所以现在，ecall帮我们做了一点点工作，但是实际上我们离执行内核中的C代码还差的很远。接下来：</p><ul><li>我们需要保存32个用户寄存器的内容，这样当我们想要恢复用户代码执行时，我们才能恢复这些寄存器的内容。</li><li><strong>因为现在我们还在user page table，我们需要切换到kernel page table。</strong></li><li>我们需要创建或者找到一个kernel stack，并将Stack Pointer寄存器的内容指向那个kernel stack。这样才能给C代码提供栈。</li><li>我们还需要跳转到内核中C代码的某些合理的位置。</li></ul><p><strong>ecall并不会为我们做这里的任何一件事（以上四点的详细实现过程在三、uservec上）。</strong></p><h5 id="2-3-1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）"><a href="#2-3-1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）" class="headerlink" title="2.3.1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）"></a>2.3.1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）</h5><p>当然，我们可以通过修改硬件让ecall为我们完成这些工作，而不是交给软件来完成。并且，我们也将会看到，在软件中完成这些工作并不是特别简单。所以你现在就会问，为什么ecall不多做点工作来将代码执行从用户空间切换到内核空间呢？为什么ecall不会保存用户寄存器，或者切换page table指针来指向kernel page table，或者自动的设置Stack Pointer指向kernel stack，或者直接跳转到kernel的C代码，而不是在这里运行复杂的汇编代码？</p><p>实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是RISC-V并不会，RISC-V秉持了这样一个观点：ecall只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管XV6并没有使用这里提供的灵活性，但是一些其他的操作系统用到了。</p><ul><li>举个例子，因为这里的ecall是如此的简单，或许某些操作系统可以在不切换page table的前提下，执行部分系统调用。切换page table的代价比较高，如果ecall打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换page table。</li><li>某些操作系统同时将user和kernel的虚拟地址映射到一个page table中，这样在user和kernel之间切换时根本就不用切换page table。对于这样的操作系统来说，如果ecall切换了page table那将会是一种浪费，并且也减慢了程序的运行。</li><li>或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于于软件，编程语言，和编译器。通过不保存所有的32个寄存器或许可以节省大量的程序运行时间，所以你不会想要ecall迫使你保存所有的寄存器。</li><li>最后，对于某些简单的系统调用或许根本就不需要任何stack，所以对于一些非常关注性能的操作系统，ecall不会自动为你完成stack切换是极好的。</li></ul><p>所以，<strong>ecall尽量的简单可以提升软件设计的灵活性</strong>。</p><h5 id="2-3-2-为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）"><a href="#2-3-2-为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）" class="headerlink" title="2.3.2 为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）"></a>2.3.2 为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）</h5><p>ecall只会更新CPU中的mode标志位为supervisor，并且设置程序计数器成STVEC寄存器内的值。在进入到用户空间之前，内核会将trampoline page的地址存在STVEC寄存器中。所以ecall的下一条指令的位置是STVEC指向的地址，也就是trampoline page的起始地址。（注，实际上ecall是CPU的指令，自然在gdb中看不到具体内容）</p><h3 id="3-ret"><a href="#3-ret" class="headerlink" title="3.ret"></a>3.ret</h3><p>返回到用户态程序原本的运行位置，PC值从<code>SEPC</code>寄存器中读取</p><h2 id="三、trampoline-page"><a href="#三、trampoline-page" class="headerlink" title="三、trampoline page"></a>三、trampoline page</h2><p>在ecall函数执行完后，程序pc值指向了uservec函数，该函数位于trampoline page的起始，<strong>仍处于 user page table中（意味着页表没有发生切换，该页表上没有处理system call 的内核代码，需要我们切换到kernel page table上）</strong></p><img src="/posts/932c8df1/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" class="" title="image-20240421182525160"><h3 id="1-trampoline-映射时的特别之处"><a href="#1-trampoline-映射时的特别之处" class="headerlink" title="1.trampoline 映射时的特别之处"></a>1.trampoline 映射时的特别之处</h3><p>在<code>kernel page table</code>中，trampoline使用直接映射，映射虚拟地址最高处为trampoline</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// map the trampoline page to the highest address,</span><br><span class="line">// in both user and kernel space.</span><br><span class="line">#define TRAMPOLINE (MAXVA - PGSIZE)</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvminit()</span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = (pagetable_t) kalloc();</span><br><span class="line">  memset(kernel_pagetable, 0, PGSIZE);</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  // map the trampoline for trap entry/exit to</span><br><span class="line">  // the highest virtual address in the kernel.</span><br><span class="line">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在为进程分配<code>user page table</code>时,虚拟地址的最高处同样映射为Trampoline，同时<strong>PTE_U为复位（0）</strong>，表明只有supervisor可以使用它，并且映射trampoline时使用的物理地址与<code>kernel page table</code>使用的物理地址一致，这意味着：**<code>kernel page table</code>与<code>user page table</code>的虚拟地址的最高处映射了同一个Trampoline**。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-Uservec函数"><a href="#2-Uservec函数" class="headerlink" title="2.Uservec函数"></a>2.Uservec函数</h3><p><code>uservec</code> 为汇编代码，代码可以在<code>kernel/trampoline.S</code>中查看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line"># swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line"># save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><h4 id="2-1-csrrw-a0-sscratch-a0"><a href="#2-1-csrrw-a0-sscratch-a0" class="headerlink" title="2.1 csrrw a0, sscratch, a0"></a>2.1 csrrw a0, sscratch, a0</h4><p>在进入到user space之前，内核会将trapframe page的地址保存在<strong>SSCRATCH寄存器</strong>中，也就是0x3fffffe000这个地址。</p><p><strong>csrrw指令</strong>，交换了a0与sscratch寄存器的值，现在a0寄存器中存储的是<strong>trapframe page的地址</strong>，其在<code>user page table</code></p><p>中被映射到了Trampoline的下方。</p><h5 id="问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？"><a href="#问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？" class="headerlink" title="问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？"></a>问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？</h5><p>在内核<strong>前一次切换回用户空间时</strong>，内核会执行set sscratch指令，将这个寄存器的内容设置为0x3fffffe000，也就是trapframe page的虚拟地址。所以，当我们在运行用户代码，比如运行Shell时，SSCRATCH保存的就是指向trapframe的地址。之后，Shell执行了ecall指令，跳转到了trampoline page，这个page中的第一条指令会交换a0和SSCRATCH寄存器的内容。所以，SSCRATCH中的值，也就是指向trapframe的指针现在存储与a0寄存器中</p><h6 id="深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？"><a href="#深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？" class="headerlink" title="深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？"></a>深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？</h6><p>这个寄存器存在于CPU上，这是CPU上的一个特殊寄存器。内核在什么时候设置的它呢？这有点复杂。它被设置的实际位置，我们可以看下<code>kernel/trampoline.S</code>末尾的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// kernel/trampoline.S</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line"># return to user mode and user pc.</span><br><span class="line"># usertrapret() set up sstatus and sepc.</span><br><span class="line">sret</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码是<strong>内核在返回到用户空间之前执行的最后两条指令</strong>。在内核返回到用户空间时，会恢复所有的用户寄存器。之后会再次执行交换指令，csrrw。**因为之前内核已经设置了a0保存的是trapframe地址(注意：从uservec到trampoline代码结尾过程中执行了诸如usertrap、usertrapret等代码，那么a0寄存器一定不是之前<code>csrrw a0, sscratch, a0</code>代码修改后的a0值)**，经过交换之后SSCRATCH仍然指向了trapframe page地址，而a0也恢复成了之前的数值。</p><p>最后<code>sret</code>返回到了用户空间</p><h6 id="a0寄存器中的值是怎么来的？"><a href="#a0寄存器中的值是怎么来的？" class="headerlink" title="a0寄存器中的值是怎么来的？"></a>a0寄存器中的值是怎么来的？</h6><p>查看<code>kernel/trap.c</code>中<code>usertrapret</code>函数的最后两行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  // jump to trampoline.S at the top of memory, which </span><br><span class="line">  // switches to the user page table, restores user registers,</span><br><span class="line">  // and switches to user mode with sret.</span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是内核返回到用户空间的最后的C函数。C函数做的最后一件事情是调用fn函数，传递的参数是TRAMFRAME和user page table。<strong>在C代码中，当你调用函数，第一个参数会存在a0</strong>，这就是为什么a0里面的数值是指向trapframe的指针。</p><h6 id="当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）"><a href="#当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）" class="headerlink" title="当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）"></a>当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）</h6><p>好的，或许对于这个问题的一个答案是：<strong>一台机器总是从内核开始运行的</strong>，当机器启动的时候，它就是在内核中。 任何时候，不管是进程第一次启动还是从一个系统调用返回，进入到用户空间的唯一方法是就是执行sret指令。sret指令是由RISC-V定义的用来从supervisor mode转换到user mode。所以，在任何用户代码执行之前，内核会执行fn函数，并设置好所有的东西，例如SSCRATCH，STVEC寄存器。</p><h4 id="2-2-sd-ra-40-a0"><a href="#2-2-sd-ra-40-a0" class="headerlink" title="2.2 sd ra, 40(a0)"></a>2.2 sd ra, 40(a0)</h4><p>现在我们保存了a0中原有的值，并且得到了trapframe page的地址，user mode下其余寄存器中的值，可以<strong>通过sd指令保存到<code>user page table</code>中trapframe的不同偏移位置</strong></p><h5 id="问题-寄存器保存在了trapframe-page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe-page），而不是使用程序的栈"><a href="#问题-寄存器保存在了trapframe-page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe-page），而不是使用程序的栈" class="headerlink" title="问题 寄存器保存在了trapframe page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe page），而不是使用程序的栈?"></a>问题 寄存器保存在了trapframe page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe page），而不是使用程序的栈?</h5><p>这里或许有两个问题:</p><p>1.为什么我们要保存寄存器？为什么内核要保存寄存器的原因，是因为内核即将要运行会覆盖这些寄存器的C代码。如果我们想正确的恢复用户程序，我们需要将这些寄存器恢复成它们在ecall调用之前的数值，所以我们需要将所有的寄存器都保存在trapframe中，这样才能在之后恢复寄存器的值</p><p>2.为什么这些寄存器保存在trapframe，而不是用户代码的栈中？这个问题的答案是，我们不确定用户程序是否有栈，必然有一些编程语言没有栈，对于这些编程语言的程序，Stack Pointer不指向任何地址。当然，也有一些编程语言有栈，但是或许它的格式很奇怪，内核并不能理解。比如，编程语言以堆中以小块来分配栈，编程语言的运行时知道如何使用这些小块的内存来作为栈，但是内核并不知道。所以，如果我们想要运行任意编程语言实现的用户程序，内核就不能假设用户内存的哪部分可以访问，哪部分有效，哪部分存在。所以内核需要自己管理这些寄存器的保存，这就是为什么内核将这些内容保存在属于内核内存的trapframe中，而不是用户内存</p><h4 id="2-3-csrr-t0-sscratch-sd-t0-112-a0"><a href="#2-3-csrr-t0-sscratch-sd-t0-112-a0" class="headerlink" title="2.3   csrr t0, sscratch ;sd t0, 112(a0)"></a>2.3   csrr t0, sscratch ;sd t0, 112(a0)</h4><p>将<code>sscratch</code>中的值（实际上是a0寄存器中的原始值）保存在t0寄存器当中，将t0寄存器中的值保存在trapframe page偏移112字节的位置当中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//kernel/proc.h</span><br><span class="line">struct trapframe &#123;</span><br><span class="line"> ......</span><br><span class="line"> /* 112 */ uint64 a0;</span><br><span class="line"> .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据结构体定义，trapframe page 偏移112字节的位置是a0寄存器。</p><p>所以这两行代码的<strong>实际作用</strong>：将a0寄存器原本的值正确的保存在trapframe 当中</p><h4 id="2-4-ld-sp-8-a0"><a href="#2-4-ld-sp-8-a0" class="headerlink" title="2.4 ld sp, 8(a0)"></a>2.4 ld sp, 8(a0)</h4><p>该指令将a0偏移8个字节的数据加载到sp（stack pointer）寄存器当中，a0寄存器当中存储的是trapframe page的地址。通过查看trapframe page的结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//kernel/proc.h</span><br><span class="line">struct trapframe &#123;</span><br><span class="line">  /*   0 */ uint64 kernel_satp;   // kernel page table</span><br><span class="line">  /*   8 */ uint64 kernel_sp;     // top of process&#x27;s kernel stack</span><br><span class="line">  /*  16 */ uint64 kernel_trap;   // usertrap()</span><br><span class="line">  /*  24 */ uint64 epc;           // saved user program counter</span><br><span class="line">  /*  32 */ uint64 kernel_hartid; // saved kernel tp</span><br><span class="line"> ......</span><br><span class="line"> ......</span><br><span class="line"> .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>所以这条指令的作用是初始化Stack Pointer指向这个进程的kernel stack的最顶端。</strong></p><p>接下来的代码作用相似，从<code>trapframe page</code>当中取出<code>current hartid</code><em>(因为在RISC-V中，没有一个直接的方法来确认当前运行在多核处理器的哪个核上，XV6会将CPU核的编号也就是hartid保存在tp寄存器)<em>、<code>address of usertrap</code></em>(将要执行的第一个C函数的指针，也就是函数usertrap的指针。我们在后面会使用这个指针)</em></p><h4 id="2-5-ld-t1-0-a0-csrw-satp-t1-sfence-vma-zero-zero"><a href="#2-5-ld-t1-0-a0-csrw-satp-t1-sfence-vma-zero-zero" class="headerlink" title="2.5 ld t1, 0(a0);csrw satp, t1;sfence.vma zero, zero"></a>2.5 ld t1, 0(a0);csrw satp, t1;sfence.vma zero, zero</h4><p>第一行代码的作用是将kernel_satp 代码加载到t1寄存器</p><p>第二行代码的作用是将stap寄存器与t1寄存器的交换，<strong>当前程序会从user page table切换到kernel page table</strong></p><p>第三行代码的作用是，清除TLB缓存，当我们切换stap寄存器所存的值时，一般都需要清除TLB缓存。</p><h5 id="为什么代码没有崩溃？（来自于老师提问）"><a href="#为什么代码没有崩溃？（来自于老师提问）" class="headerlink" title="为什么代码没有崩溃？（来自于老师提问）"></a>为什么代码没有崩溃？（来自于老师提问）</h5><p>毕竟我们在内存中的某个位置执行代码，程序计数器保存的是虚拟地址，如果我们切换了page table，为什么同一个虚拟地址不会通过新的page table寻址走到一些无关的page中？看起来我们现在没有崩溃并且还在执行这些指令。</p><h6 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h6><p>trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。</p><p><strong>之所以叫trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。</strong></p><h4 id="2-6-jr-t0"><a href="#2-6-jr-t0" class="headerlink" title="2.6 jr t0"></a>2.6 jr t0</h4><p>t0寄存器的值在2.4中提到过，现在其中的值为<code>usertrap</code>函数的地址，通过这段代码我们跳转到了<code>usertrap</code>函数，进行接下来的操作。</p><h2 id="四、Usertrap函数"><a href="#四、Usertrap函数" class="headerlink" title="四、Usertrap函数"></a>四、Usertrap函数</h2><p>在<code>Uservec</code>函数的结尾，我们跳转到了Usertrap函数,所以程序现在运行usertrap函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  更改STVEC寄存器。取决于trap是来自于用户空间还是内核空间，实际上XV6处理trap的方法是不一样的。目前为止，我们只讨论过当trap是由用户空间发起时会发生什么。如果trap从内核空间发起，将会是一个非常不同的处理流程，因为从内核发起的话，程序已经在使用kernel page table。所以当trap发生时，程序执行仍然在内核的话，很多处理都不必存在</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取当前正在运行的进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  保存用户程序计数器，它仍然保存在SEPC寄存器中</span></span><br><span class="line"><span class="comment">  但是可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致SEPC寄存器的内容被覆盖。所以，我们需要保存当前进程的SEPC寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。这里我们使用trapframe来保存这个程序计数器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  <span class="comment">//根据触发trap的原因，RISC-V的SCAUSE寄存器会有不同的数字。数字8表明，我们现在在trap代码中是因为系统调用</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    XV6会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，我们需要显式的打开中断。（发生中断时，中断会关闭）</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    intr_on();</span><br><span class="line"><span class="comment">//进入syscall函数</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>usertrap</code>函数中我们可以看到，倘若中断的原因是由<code>system call</code>引起的<code>（r_scause() == 8）</code>，那么程序将先执行<code>syscall（）</code>函数，再执行<code>usertrapret()</code>函数</p><h4 id="什么时候r-scause（）被设置"><a href="#什么时候r-scause（）被设置" class="headerlink" title="什么时候r_scause（）被设置"></a>什么时候<code>r_scause（）</code>被设置</h4><p>每个RISC-V CPU都有一组控制寄存器，内核通过向这些寄存器写入内容来告诉CPU如何处理陷阱，内核可以读取这些寄存器来明确已经发生的陷阱。</p><p>以下是最重要的一些寄存器概述：</p><ul><li><code>stvec</code>：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。</li><li><code>sepc</code>：当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li><li><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</li><li><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</li><li><code>sstatus</code>：其中的<strong>SIE</strong>位控制设备中断是否启用。如果内核清空<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核重新设置<strong>SIE</strong>。<strong>SPP</strong>位指示陷阱是来自用户模式还是管理模式，并控制<code>sret</code>返回的模式。</li></ul><p><strong>上述寄存器都用于在管理模式下处理陷阱，在用户模式下不能读取或写入。</strong>在机器模式下处理陷阱有一组等效的控制寄存器，xv6仅在计时器中断的特殊情况下使用它们。</p><p>多核芯片上的<strong>每个CPU都有自己的这些寄存器集</strong>，并且在任何给定时间都可能有多个CPU在处理陷阱。</p><p><strong>当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：</strong></p><ol><li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li><li>清除<strong>SIE</strong>以<strong>禁用中断</strong>。</li><li>将<code>pc</code>复制到<code>sepc</code>。</li><li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li><li>设置<code>scause</code>以反映产生陷阱的原因。</li><li>将模式设置为管理模式。</li><li>将<code>stvec</code>复制到<code>pc</code>。</li><li>在新的<code>pc</code>上开始执行。</li></ol><p><strong>综上所述，这是硬件进行的操作，所以我们在代码中看不见过程</strong></p><h2 id="五、Systemcall"><a href="#五、Systemcall" class="headerlink" title="五、Systemcall"></a>五、Systemcall</h2><p>在<code>usertrap</code>函数中我们进入了<code>systemcall</code>函数，在用户态执行<code>ecall</code>指令前，我们将<strong>系统调用号设置到了寄存器a7</strong>,执行ecall指令后，<code>uservec</code>函数将进程寄存器的所有值都被存入到了<code>trapframe</code>当中，所以我们通过<code>num = p-&gt;trapframe-&gt;a7;</code>取出系统调用号。</p><p><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code></p><p>这里向trapframe中的a0赋值的原因是：<strong>所有的系统调用都有一个返回值，比如write会返回实际写入的字节数，而RISC-V上的C代码的习惯是函数的返回值存储于寄存器a0，所以为了模拟函数的返回，我们将返回值存储在trapframe的a0中</strong>。之后，当我们返回到用户空间，trapframe中的a0槽位的数值会写到实际的a0寄存器，Shell会认为a0寄存器中的数值是write系统调用的返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/syscall.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>kernel/syscall.c</code>中，我们可以看出syscalls是一个<strong>函数指针数组</strong>，根据我们取出的系统调用号来调用不同的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们传入的系统调用号对应的是<code>SYS_sleep</code>,所以执行<code>sys_sleep</code>函数,函数定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：我们传入到内核的只有系统调用号，并没有其他途径告知内核传入参数的个数，所以我们自定义系统调用时，需要在用户态将函数声明中形参的个数与内核中系统调用函数中取参的个数相匹配，数目对不上编译器检查不出来错误。</strong></p><p><code>sys_sleep</code>函数利用<code>argint</code>函数取出应该休眠的时间<em>（若用户态为sleep(10),则n&#x3D;&#x3D;10）</em>，进行接下来的休眠操作。</p><h2 id="六、Usertrapret"><a href="#六、Usertrapret" class="headerlink" title="六、Usertrapret"></a>六、<code>Usertrapret</code></h2><p>在<code>Usertrap</code>函数中我们可以看出，系统调用执行完成后，我们应该执行<code>usertrapret</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  我们之前在系统调用的过程中是打开了中断的，这里关闭中断是因为我们将要更新STVEC寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码（6.6）。我们关闭中断因为当我们将STVEC更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即便我们现在仍然在内核中，出于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">STVEC寄存器指向trampoline代码，在那里最终会执行sret指令返回到用户空间。位于trampoline代码最后的sret指令会重新打开中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*填入了trapframe的内容，这些内容对于执行trampoline代码非常有用。这样下一次从用户空间转换到内核空间时可以用到这些数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  设置SSTATUS寄存器，这是一个控制寄存器。这个寄存器的SPP bit位控制了sret指令的行为，该bit为0表示下次执行sret的时候，我们想要返回user mode而不是supervisor mode。这个寄存器的SPIE bit位控制了，在执行完sret之后，是否打开中断。因为我们在返回到用户空间之后，我们的确希望打开中断，所以这里将SPIE bit位设置为1。修改完这些bit位之后，我们会把新的值写回到SSTATUS寄存器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">trampoline代码的最后执行了sret指令。这条指令会将程序计数器设置成SEPC寄存器的值，所以现在我们将SEPC寄存器的值设置成之前保存的用户程序计数器的值。在不久之前，我们在usertrap函数中将用户程序计数器保存在trapframe中的epc字段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">们根据user page table地址生成相应的SATP值，这样我们在返回到用户空间的时候才能完成page table的切换。实际上，我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中代码是同时在用户和内核空间中映射。但是我们现在还没有在trampoline代码中，我们现在还在一个普通的C函数中，所以这里我们将page table指针准备好，并将这个指针作为第二个参数传递给汇编代码，这个参数会出现在a1寄存器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  倒数第二行的作用是计算出我们将要跳转到汇编代码的地址。我们期望跳转的地址是tampoline中的userret函数，这个函数包含了所有能将我们带回到用户空间的指令。所以这里我们计算出了userret函数的地址</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  倒数第一行，将fn指针作为一个函数指针，执行相应的函数（也就是userret函数）并传入两个参数，两个参数存储在a0，a1寄存器中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、Userret"><a href="#七、Userret" class="headerlink" title="七、Userret"></a>七、<code>Userret</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        /*</span><br><span class="line">        在执行csrw satp, a1之前，page table应该还是巨大的kernel page table。这条指令会将user page table（在usertrapret中作为第二个参数传递给了这里的userret函数，所以存在a1寄存器中）存储在SATP寄存器中。执行完这条指令之后，page table就变成了小得多的user page table。但是幸运的是，user page table也映射了trampoline page，所以程序还能继续执行而不是崩溃</span><br><span class="line">        */</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        // 清空页表缓存</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        /*</span><br><span class="line">        将SSCRATCH寄存器恢复成保存好的用户的a0寄存器。在这里a0是trapframe的地址，因为C代码usertrapret函数中将trapframe地址作为第一个参数传递过来了。112是a0寄存器在trapframe中的位置</span><br><span class="line">        */</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line">/*</span><br><span class="line">之前保存的寄存器的值加载到对应的各个寄存器中</span><br><span class="line">*/</span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line">        //a0寄存器现在还是个例外，它现在仍然是指向trapframe的指针，而不是保存了的用户数据。</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        交换SSCRATCH寄存器和a0寄存器的值。前面我们看过了SSCRATCH现在的值是系统调用的返回值</span><br><span class="line">        */</span><br><span class="line">        # restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        /*</span><br><span class="line">        sret 的三个作用:</span><br><span class="line">        1.程序会切换回user mode</span><br><span class="line">        2.SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器） （usertrap中保存的）</span><br><span class="line">        3.重新打开中断（usertrapret中保存的）</span><br><span class="line">        */</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p><code>sret</code>最终返回到usermode，此时 **我们处于 系统调用 化身成为的三条汇编指令的最后一句：<code>ret</code>**，执行后回到调用<code>sleep</code>函数的地方</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>系统调用被刻意设计的看起来像是函数调用，但是背后的user&#x2F;kernel转换比函数调用要复杂的多。<strong>之所以这么复杂，很大一部分原因是要保持user&#x2F;kernel之间的隔离性，内核不能信任来自用户空间的任何内容。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT6.S081 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Systemcall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081_2020_Lab3:page tables</title>
      <link href="/posts/c808110f.html"/>
      <url>/posts/c808110f.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://xv6.dgs.zone/labs/requirements/lab3.html">实验要求</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来想把MIT6.S081的每个lab都做一个总结，后来发现单单做一个lab3就已经很费力气，后续打算只将较难的实验总结出来</p><h2 id="一、理清实验的目的：原本的流程存在什么问题？我们为什么要这样做？"><a href="#一、理清实验的目的：原本的流程存在什么问题？我们为什么要这样做？" class="headerlink" title="一、理清实验的目的：原本的流程存在什么问题？我们为什么要这样做？"></a>一、理清实验的目的：原本的流程存在什么问题？我们为什么要这样做？</h2><p>虚拟地址(virtual address -va)到物理地址(physical address-pa)的转化需要借助MMU（内存管理单元<strong>MMU，Memory Management Unit</strong>），XV6 中MMU可以将<strong>satp中装载的内核页表</strong>上的虚拟地址转化为物理地址。</p><p>Xv6为每个进程维护一个页表，用以描述每个进程的用户地址空间（pagetable）；外加一个单独描述内核地址空间的页表（<strong>kernel_pagetable</strong>）<strong>（该页表始终在satp中装载）</strong>。</p><p>这种构造导致kernel_pagetable中<strong>没有存储</strong> <strong>单一进程</strong>的虚拟地址与物理地址的映射关系，MMU无法根据给出的虚拟地址来直接得到对应的物理地址。</p><h3 id="1-xv6对待用户地址传来的虚拟地址采用间接查询的方法来查询对应物理地址"><a href="#1-xv6对待用户地址传来的虚拟地址采用间接查询的方法来查询对应物理地址" class="headerlink" title="1.xv6对待用户地址传来的虚拟地址采用间接查询的方法来查询对应物理地址"></a><strong>1.xv6对待用户地址传来的虚拟地址采用间接查询的方法来查询对应物理地址</strong></h3><p><strong>这种方法的实现关键XV6采用的 虚拟地址与物理地址的映射关系 与 walk函数（kernel&#x2F;vm.c）</strong></p><h4 id="1-1虚拟地址与物理地址映射"><a href="#1-1虚拟地址与物理地址映射" class="headerlink" title="1.1虚拟地址与物理地址映射"></a>1.1虚拟地址与物理地址映射</h4><img src="/posts/c808110f/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png" class="" title="虚拟地址与物理地址映射"><p>XV6系统的虚拟地址有64位，但本系统基于Sv39 RISC-V运行，这意味着它<strong>只使用64位虚拟地址的低39位</strong>；而高25位不使用。</p><p>低12位的<strong>Offset</strong>为字节偏移量，地址空间本身是以<strong>4096byte为单位</strong>进行分配的，<strong>Offset</strong>用于定位虚拟地址在页表中的起始位置。进行地址转化时，<strong>虚拟地址中的Offset应该保留在物理地址的低12位。</strong></p><p>页表以<strong>三级的树型结构</strong>存储在物理内存中。</p><p>剩余<strong>27位（39-12）</strong>被分为3部分，用来索引不同层级的PTE（PageTable Entry）,可以将Page Table 理解为数组首元素，那么9位的地址可以看作偏移量，<strong>首元素地址+偏移量&#x3D;&#x3D;PTE</strong></p><p>PTE分为两部分：Physical Page Number（PPN） 与 FLags，PPN用于指出下一Page Table的地址（首元素地址），FLag表示操作系统拥有的权限（<strong>Xv6系统的权限管理简单，只拥有用户态和内核态的区别，没有引入多用户权限管理）</strong>。</p><p>以上的结构意味着，<strong>只需要给出虚拟地址与最高级页表对应的物理地址，我们可以不借助MMU就查询到虚拟地址最后所对应的物理地址。</strong>实际上walk函数就是基于这个思想实现的。</p><h4 id="1-2walk函数"><a href="#1-2walk函数" class="headerlink" title="1.2walk函数"></a>1.2walk函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据Level不同，取出不同的偏移值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br><span class="line"><span class="comment">//将物理地址pa转化为pte地址，右移12位是去除OFFSET，左移10位是为FLAG留下空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="comment">//将pte地址转化为pa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//检查虚拟地址是否合法，MAXVA为虚拟地址的最大值</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<span class="comment">//去除va对应level的9bit地址，即pte</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//查询的PTE暂时不存在</span></span><br><span class="line">      <span class="comment">//如果alloc==0或者剩余空间不足，那么就无法分配新的物理地址给PTE,返回0（失败）</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];<span class="comment">//返回level为0的最低pte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3原来的copyin函数"><a href="#1-3原来的copyin函数" class="headerlink" title="1.3原来的copyin函数"></a>1.3原来的copyin函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page以4096个字节为单位，取a所在page的结束地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">//page以4096个字节为单位，取a所在page的起始地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Look up a virtual address, return the physical address,</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">   uint64 n, va0, pa0;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         va0 = PGROUNDDOWN(srcva);</span><br><span class="line">         pa0 = walkaddr(pagetable, va0);</span><br><span class="line">         <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">         n = PGSIZE - (srcva - va0);</span><br><span class="line">         <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">           n = len;</span><br><span class="line">         memmove(dst, (<span class="type">void</span> *)(pa0 + (srcva - va0)), n);</span><br><span class="line">         len -= n;</span><br><span class="line">         dst += n;</span><br><span class="line">         srcva = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，原本的copyin函数就是通过使用walk函数查找va对应的pa，将数据从用户复制到内核。</p><h4 id="1-4本实验的目的"><a href="#1-4本实验的目的" class="headerlink" title="1.4本实验的目的"></a>1.4本实验的目的</h4><p>将数据从用户复制到内核，原本需要借助walk函数<strong>查询三次</strong>页表，实验要求我们完成之后不借助walk函数，通过MMU来找到物理地址。</p><h3 id="2-为什么要使用MMU？其相比walk函数优越在哪？"><a href="#2-为什么要使用MMU？其相比walk函数优越在哪？" class="headerlink" title="2.为什么要使用MMU？其相比walk函数优越在哪？"></a>2.为什么要使用MMU？其相比walk函数优越在哪？</h3><p><strong>其实这个问题也可以理解为：既然通过使用函数调用的方式就可以将虚拟地址VA转化为物理地址PA，那么我们为什么还需要一个MMU硬件？</strong></p><p>我们可以再将这个问题深化，<strong>为什么计算机许多功能，我们通过软件可以实现，还要设计一个专用的硬件来实现这个功能呢？</strong></p><h4 id="2-1专用硬件意味着对CPU占用的减少，会增加计算机的运行速度"><a href="#2-1专用硬件意味着对CPU占用的减少，会增加计算机的运行速度" class="headerlink" title="2.1专用硬件意味着对CPU占用的减少，会增加计算机的运行速度"></a>2.1专用硬件意味着对CPU占用的减少，会增加计算机的运行速度</h4><p>CPU资源在计算机的运行过程中是很宝贵的，我们为常用的功能设计一个硬件，便可以减少对CPU资源的占用，让它分配给更需要的程序。比如GPU的诞生就是为了将图形相关的计算从CPU分离出来，提高计算机的运行效率。</p><h4 id="2-2回归MMU本身，MMU等硬件可以通过TLB（Translation-Look-aside-Buffer）等机制来获得比CPU更快的速度"><a href="#2-2回归MMU本身，MMU等硬件可以通过TLB（Translation-Look-aside-Buffer）等机制来获得比CPU更快的速度" class="headerlink" title="2.2回归MMU本身，MMU等硬件可以通过TLB（Translation Look-aside Buffer）等机制来获得比CPU更快的速度"></a>2.2回归MMU本身，MMU等硬件可以通过TLB（Translation Look-aside Buffer）等机制来获得比CPU更快的速度</h4><h4 id="2-3既然计算机拥有MMU这个硬件，那么我们就应该尽量让MMU能实现的功能通过MMU实现，而非自己编写函数通过CPU实现"><a href="#2-3既然计算机拥有MMU这个硬件，那么我们就应该尽量让MMU能实现的功能通过MMU实现，而非自己编写函数通过CPU实现" class="headerlink" title="2.3既然计算机拥有MMU这个硬件，那么我们就应该尽量让MMU能实现的功能通过MMU实现，而非自己编写函数通过CPU实现"></a>2.3<strong>既然计算机拥有MMU这个硬件，那么我们就应该尽量让MMU能实现的功能通过MMU实现，而非自己编写函数通过CPU实现</strong></h4><h3 id="3-修改后的虚拟地址转化方式"><a href="#3-修改后的虚拟地址转化方式" class="headerlink" title="3.修改后的虚拟地址转化方式"></a>3.修改后的虚拟地址转化方式</h3><ol><li><p>MMU的实现需要我们在stap中设定正确的page table，这意味着我们<strong>在用户态与内核态的切换过程中，需要切换stap所指的page table</strong>，我们为每一个进程都设置一个<strong>proc_kernel_pagetable</strong></p></li><li><p>切换page table除了能够满足转化用户态的虚拟地址到物理地址的功能，还要保证内核态原本功能的正常运行。</p><p>为了满足以上两点要求，势必<strong>要求我们对kernel_pagetable（描述内核地址空间的页表）的具体构成有更加深入的了解</strong></p></li></ol><img src="/posts/c808110f/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8C%96%E6%96%B9%E5%BC%8F.png" class="" title="image-20240420181130319"><h2 id="二、进程地址空间的认识与修改"><a href="#二、进程地址空间的认识与修改" class="headerlink" title="二、进程地址空间的认识与修改"></a>二、进程地址空间的认识与修改</h2><p><a href="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c3/s2.html">XV6 地址空间的介绍</a></p><img src="/posts/c808110f/xv6%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" class="" title="image-20240420163322936"><h3 id="1-物理地址的布局（图右）"><a href="#1-物理地址的布局（图右）" class="headerlink" title="1.物理地址的布局（图右）"></a>1.物理地址的布局（图右）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/home/shui/xv6-labs-2020/kernel/memlayout.h</span><br><span class="line"></span><br><span class="line">// 物理地址布局</span><br><span class="line">// Physical memory layout</span><br><span class="line"></span><br><span class="line">// qemu -machine virt is set up like this,</span><br><span class="line">// based on qemu&#x27;s hw/riscv/virt.c:</span><br><span class="line">//</span><br><span class="line">// 00001000 -- boot ROM, provided by qemu</span><br><span class="line">// 02000000 -- CLINT</span><br><span class="line">// 0C000000 -- PLIC</span><br><span class="line">// 10000000 -- uart0 </span><br><span class="line">// 10001000 -- virtio disk </span><br><span class="line">// 80000000 -- boot ROM jumps here in machine mode</span><br><span class="line">//             -kernel loads the kernel here</span><br><span class="line">// unused RAM after 80000000.</span><br><span class="line"></span><br><span class="line">// the kernel uses physical memory thus:</span><br><span class="line">// 80000000 -- entry.S, then kernel text and data</span><br><span class="line">// end -- start of kernel page allocation area</span><br><span class="line">// PHYSTOP -- end RAM used by the kernel</span><br></pre></td></tr></table></figure><p>0x02000000-KERNBASE 为 I&#x2F;O devices，为硬件对应的物理地址</p><p><strong>KERNBASE(80000000)-end（</strong>*&#x2F;&#x2F; first address after kernel .defined by kernel.ld.*<strong>）</strong> kernel 加载的区域，</p><p><strong>end-PHYSTOP（<code>#define PHYSTOP (KERNBASE + 128*1024*1024)</code>）</strong> <strong>实际参与Page分配（kalloc）的物理地址</strong></p><h3 id="2-内核地址空间（kernel-pagetable）的页表布局（图左）"><a href="#2-内核地址空间（kernel-pagetable）的页表布局（图左）" class="headerlink" title="2.内核地址空间（kernel_pagetable）的页表布局（图左）"></a>2.内核地址空间（<strong>kernel_pagetable</strong>）的页表布局（图左）</h3><p>​<img src="/posts/c808110f/xv6%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" class="" title="image-20240420163322936"></p><h4 id="2-1-内核使用“直接映射”获取内存和内存映射设备寄存器；也就是说，将资源映射到等于物理地址的虚拟地址。"><a href="#2-1-内核使用“直接映射”获取内存和内存映射设备寄存器；也就是说，将资源映射到等于物理地址的虚拟地址。" class="headerlink" title="2.1 内核使用“直接映射”获取内存和内存映射设备寄存器；也就是说，将资源映射到等于物理地址的虚拟地址。"></a>2.1 <strong>内核使用“直接映射”获取内存和内存映射设备寄存器；也就是说，将资源映射到等于物理地址的虚拟地址。</strong></h4><p>那么意味着我们的<strong>proc_kernel_pagetable</strong>，需要模仿<strong>kernel_pagetable</strong>，映射内存和内存映射设备寄存器</p><p>kernel_pagetable 内核页表直接映射的相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/kernel/vm.c</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create a direct-map page table for the kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//分配page </span></span><br><span class="line">  kernel_pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="comment">//用0填充page继续初始化</span></span><br><span class="line">  <span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="comment">//直接映射I/0设备</span></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pagetable上映射va到pa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化进程自己的内核页表,这个kernelpagetable可以看作proc_kernel_pagetable：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">uvmkernelpagetableinit</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kernelpagetable=uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(kernelpagetable==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  uvmmap(kernelpagetable,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  uvmmap(kernelpagetable,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT 用户进程的最大地址空间不能超过plic，所以不要映射plic</span></span><br><span class="line">  <span class="comment">// uvmmap(kernelpagetable,CLINT, CLINT, 0x10000, PTE_R | PTE_W);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  uvmmap(kernelpagetable,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  uvmmap(kernelpagetable,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  uvmmap(kernelpagetable,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  uvmmap(kernelpagetable,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kernelpagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2在原本的内核页表中（kernel-pagetable），每一个进程都有对应的内核栈，我们应该确保进程自身的内核页表-proc-kernel-pagetable-，拥有进程自身的内核栈"><a href="#2-2在原本的内核页表中（kernel-pagetable），每一个进程都有对应的内核栈，我们应该确保进程自身的内核页表-proc-kernel-pagetable-，拥有进程自身的内核栈" class="headerlink" title="2.2在原本的内核页表中（kernel_pagetable），每一个进程都有对应的内核栈，我们应该确保进程自身的内核页表(proc_kernel_pagetable)，拥有进程自身的内核栈"></a>2.2在原本的内核页表中（<strong>kernel_pagetable</strong>），每一个进程都有对应的内核栈，我们应该确保进程自身的内核页表(proc_kernel_pagetable)，拥有进程自身的内核栈</h4><p><strong>kernel_pagetable为每一个进程分配内核栈：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">      <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">      <span class="comment">// guard page.</span></span><br><span class="line">      <span class="type">char</span> *pa = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">      uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">      p-&gt;kstack = va;</span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来的kernel_pagetable为每一个进程分配内核栈，在为每一个进程增加一个proc_kernel_pagetable后，<strong>我们只在没有进程运行时才在stap中加载kernel_pagetable，所以proc_kernel_pagetable上映射的kstack与kernel_pagetable不同也可以</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/kernel/proc.c static struct proc* allocproc(void)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在进程的内核页表中设置直接映射，并设置guard page，</span><br><span class="line">  char *pa = kalloc();</span><br><span class="line">      if(pa == 0)</span><br><span class="line">        panic(&quot;kalloc&quot;);</span><br><span class="line">      uint64 va = KSTACK((int) (p - proc));</span><br><span class="line">      uvmmap(p-&gt;kernelpagetable,va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">      p-&gt;kstack = va;</span><br><span class="line"></span><br><span class="line">// map kernel stacks beneath the trampoline,</span><br><span class="line">// each surrounded by invalid guard pages.</span><br><span class="line">#define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE）</span><br></pre></td></tr></table></figure><h5 id="2-2-1guard-page是什么？"><a href="#2-2-1guard-page是什么？" class="headerlink" title="2.2.1guard page是什么？"></a>2.2.1guard page是什么？</h5><p>每个进程都有自己的内核栈，它将映射到偏高一些的地址，这样xv6在它之下就可以留下一个未映射的保护页(guard page)。保护页的PTE是无效的（也就是说PTE_V没有设置），所以如果内核溢出内核栈就会引发一个异常，内核触发panic。如果没有保护页，栈溢出将会覆盖其他内核内存，引发错误操作。恐慌崩溃（panic crash）是更可取的方案。<em>（注：Guard page不会浪费物理内存，它只是占据了虚拟地址空间的一段靠后的地址，但并不映射到物理地址空间。）</em></p><h4 id="2-3-在内核更改进程的用户映射的每一处（pagetable），都以相同的方式更改进程的内核页表（proc-kernel-pagetable）"><a href="#2-3-在内核更改进程的用户映射的每一处（pagetable），都以相同的方式更改进程的内核页表（proc-kernel-pagetable）" class="headerlink" title="2.3 在内核更改进程的用户映射的每一处（pagetable），都以相同的方式更改进程的内核页表（proc_kernel_pagetable）"></a>2.3 在内核更改进程的用户映射的每一处（pagetable），都以相同的方式更改进程的内核页表（proc_kernel_pagetable）</h4><p>因为MMU本身也是需要内核页表中<strong>实际存在</strong>虚拟地址到物理地址的映射关系的，那么<strong>在涉及到用户映射的时候，我们需要将进程页表（pagetable）虚拟地址到物理地址的映射关系同步到进程的内核页表（proc_kernel_pagetable）上</strong>，实际上我们可以通过修改更多代码，让进程的内核页表完全顶替内核页表的作用，只是一口吃不成一个大胖子，我们应该先确保<strong>进程内核页表的实现</strong>，再考虑去除<strong>进程页表</strong>（实际上本人没有进行去除操作）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//将old页表中beginsz至endsz的内容，复制到new页表的beginsz至endsz</span><br><span class="line">void</span><br><span class="line">utkvmcopy(pagetable_t old, pagetable_t new, uint64 beginsz, uint64 endsz)&#123;</span><br><span class="line">  pte_t *pte_from, *pte_to;</span><br><span class="line">  beginsz = PGROUNDUP(beginsz);</span><br><span class="line">  for (uint64 i = beginsz; i &lt; endsz; i += PGSIZE)&#123;</span><br><span class="line">    if((pte_from = walk(old, i, 0)) == 0)</span><br><span class="line">      panic(&quot;utkvmcopy: src pte does not exist&quot;);</span><br><span class="line">    if((pte_to = walk(new, i, 1)) == 0)</span><br><span class="line">      panic(&quot;utkvmcopy: pte walk failed&quot;);</span><br><span class="line">    uint64 pa = PTE2PA(*pte_from);</span><br><span class="line">    uint flags = (PTE_FLAGS(*pte_from)) &amp; (~PTE_U);</span><br><span class="line">    *pte_to = PA2PTE(pa) | flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-1什么时候内核页表（pagetable）会有映射关系的改变？"><a href="#2-3-1什么时候内核页表（pagetable）会有映射关系的改变？" class="headerlink" title="2.3.1什么时候内核页表（pagetable）会有映射关系的改变？"></a>2.3.1什么时候内核页表（pagetable）会有映射关系的改变？</h5><p><strong>我们需要搞明白xv6系统每一个进程的生成方式：除了pid&#x3D;1的进程是在启动阶段生成，其余的进程都是通过fork方式从父进程中生成，我们需要复制映射关系倘若我们需要执行不同的代码，fork之后进程exec操作，将进程结构中存储的代码替换掉，我们需要修改映射关系</strong></p><p><strong>倘若进程空间不足或过多，使用sbrk函数分配新空间，我们需要增删映射关系</strong></p><p><strong>进程运行结束后，释放页表时，应该去除进程pagetable上的映射的关系</strong></p><p>而xv6本身针对于上述情况下pagetable上的映射关系变化的代码已经很完善了，我们无需做任何修改，只需要在相关代码中添加</p><p><code>utkvmcopy(p-&gt;pagetable,p-&gt;kernelpagetable,0,sz);</code></p><p>便可以让proc_kernel_pagetable中存有虚拟地址到物理地址的映射关系</p><h4 id="2-4-切换进程时-kernel-x2F-proc-c-x2F-scheduler-void-切换stap所指的页表-并刷新TLB"><a href="#2-4-切换进程时-kernel-x2F-proc-c-x2F-scheduler-void-切换stap所指的页表-并刷新TLB" class="headerlink" title="2.4 切换进程时(kernel&#x2F;proc.c&#x2F;scheduler(void)),切换stap所指的页表,并刷新TLB"></a>2.4 切换进程时(kernel&#x2F;proc.c&#x2F;scheduler(void)),切换stap所指的页表,并刷新TLB</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">uvminithart(pagetable_t kernelpagetable)&#123;</span><br><span class="line">// supervisor address translation and protection;</span><br><span class="line">// holds the address of the page table.</span><br><span class="line">  w_satp(MAKE_SATP(kernelpagetable));</span><br><span class="line">  // flush the TLB.</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、存在的问题"><a href="#三、存在的问题" class="headerlink" title="三、存在的问题"></a>三、存在的问题</h2><p>I&#x2F;O设备的虚拟地址是直接映射的，而我们将page_table上的映射关系直接复制到了proc_kernel_pagetable上，这意味这va的大小不能超过最低的I&#x2F;O设备的地址空间</p><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><h3 id="1-为什么要使用三级页表而非一级页表（来自课堂学生提问）"><a href="#1-为什么要使用三级页表而非一级页表（来自课堂学生提问）" class="headerlink" title="1.为什么要使用三级页表而非一级页表（来自课堂学生提问）"></a>1.为什么要使用三级页表而非一级页表（来自课堂学生提问）</h3><p>Frans教授：这是个好问题，这的原因是，3级page table中，大量的PTE都可以不存储。比如，对于最高级的page table里面，如果一个PTE为空，那么你就完全不用创建它对应的中间级和最底层page table，以及里面的PTE。所以，这就是像是在整个虚拟地址空间中的一大段地址完全不需要有映射一样。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT6.S081 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> MMU </tag>
            
            <tag> page </tag>
            
            <tag> 地址映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081 Operating System Engineering介绍</title>
      <link href="/posts/8a8374bd.html"/>
      <url>/posts/8a8374bd.html</url>
      
        <content type="html"><![CDATA[<h2 id="实验相关链接"><a href="#实验相关链接" class="headerlink" title="实验相关链接"></a>实验相关链接</h2><p><a href="https://www.bilibili.com/video/BV19k4y1C7kA/">哔哩哔哩网课链接</a></p><p><a href="https://xv6.dgs.zone/">实验要求翻译链接</a></p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081">课程翻译文字版本</a></p><p><a href="https://pdos.csail.mit.edu/6.828/2020/reference.html">课程阅读材料</a></p><p><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">课表安排</a></p><h2 id="其他人的总结链接"><a href="#其他人的总结链接" class="headerlink" title="其他人的总结链接"></a>其他人的总结链接</h2><ol><li><a href="https://www.cnblogs.com/David-Dong/category/2372849.html">David-Dong</a></li><li><a href="https://blog.csdn.net/u013577996/article/details/108679997">解析Ta</a></li><li><a href="https://www.zhihu.com/people/17722908726/posts">林夕丶</a></li><li><a href="https://www.cnblogs.com/weijunji/tag/XV6/">星见遥</a></li><li><a href="https://doraemonzzz.com/tags/6-S081/">Doraemonzzz</a></li></ol><h2 id="课程个人理解"><a href="#课程个人理解" class="headerlink" title="课程个人理解"></a>课程个人理解</h2><p>本课程使用RISC-V架构的<a href="https://zh.wikipedia.org/wiki/Xv6">XV6</a>操作系统,该操作系统是类Unix类型，虽然简单，但是包含了Unix的重要概念，完成所有lab后对操作系统会拥有更加深入的了解。</p><p>实验的每一个lab都有专门的代码可供打分，便于直观判断自己的代码实际效果。</p><p>并且每个lab之间互不干扰，lab3的代码不会影响lab4，这种相互隔离做法让实验的进行更加方便。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ol><li>使用ubuntu-<strong>20.04</strong>版本</li><li><a href="https://pdos.csail.mit.edu/6.828/2020/tools.html">环境配置链接</a></li></ol><h2 id="Tmux（screen类似应用）"><a href="#Tmux（screen类似应用）" class="headerlink" title="Tmux（screen类似应用）"></a>Tmux（screen类似应用）</h2><p><a href="https://blog.gtwang.org/linux/linux-tmux-terminal-multiplexer-tutorial/">相关教程</a></p><p>Tmux可以在一个窗口中使用多个终端，Linux类的操作系统在关闭终端后，正在终端中运行的程序便会终止，Tmux可以在退出窗口时保存窗口内容，后续可以通过指令快速恢复环境。*(如图：一个窗口分出来了三个终端)*</p><img src="/posts/8a8374bd/Tmux%E7%A4%BA%E6%84%8F.png" class="" title="image-20240419133645432"><h3 id="Tmux常用操作"><a href="#Tmux常用操作" class="headerlink" title="Tmux常用操作"></a>Tmux常用操作</h3><h4 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h4><p><strong>1.新建会话</strong>    <em>tmux new -s</em> <em>&lt;**session-name**&gt;</em></p><p><strong>2.分离会话</strong>    <em>tmux detach</em> 或者 <code>Ctrl+b d</code>  上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p><p><strong>3.查看当前所有的 Tmux 会话</strong><code>tmux ls</code> 或 <code>tmux list-session</code></p><p><strong>4.接入会话</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用会话编号</span><br><span class="line">$ tmux attach -t 0</span><br><span class="line"></span><br><span class="line"># 使用会话名称</span><br><span class="line">$ tmux attach -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure><p><strong>5.杀死会话</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用会话编号</span><br><span class="line">$ tmux kill-session -t 0</span><br><span class="line"># 使用会话名称</span><br><span class="line">$ tmux kill-session -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure><p><strong>6.切换会话</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用会话编号</span><br><span class="line">$ tmux switch -t 0</span><br><span class="line"></span><br><span class="line"># 使用会话名称</span><br><span class="line">$ tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure><p><strong>7.重命名会话</strong> <code>tmux rename-session -t 0 &lt;new-name&gt;</code></p><h4 id="窗格操作"><a href="#窗格操作" class="headerlink" title="窗格操作"></a>窗格操作</h4><blockquote><p>​       -<code>Ctrl+b %</code>：划分左右两个窗格。</p><ul><li><code>Ctrl+b &quot;</code>：划分上下两个窗格。</li><li><code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。</li><li><code>Ctrl+b ;</code>：光标切换到上一个窗格。</li><li><code>Ctrl+b o</code>：光标切换到下一个窗格。</li><li><code>Ctrl+b &#123;</code>：当前窗格与上一个窗格交换位置。</li><li><code>Ctrl+b &#125;</code>：当前窗格与下一个窗格交换位置。</li><li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li><li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li><li><code>Ctrl+b x</code>：关闭当前窗格。</li><li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li><li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li><li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。</li><li><code>Ctrl+b q</code>：显示窗格编号。</li></ul></blockquote><h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><p>使用 <strong>gdb-multiarch</strong> 进行调试*(xv6不是x86架构,不能使用普通的gdb直接进行调试)*</p><h3 id="一般的调试流程"><a href="#一般的调试流程" class="headerlink" title="一般的调试流程"></a>一般的调试流程</h3><ol><li><p>tmux在窗口中建立两个终端</p></li><li><p>终端1在<strong>代码目录</strong>下输入<code>make clean</code>清除实验缓存</p></li><li><p>终端1在<strong>代码目录</strong>下输入<code>make qemu-gdb</code>打开调试模式*(make CPUS&#x3D;1 qemu-gdb 为单核调试模式)*,出现</p></li><li><p>终端2在<strong>代码目录</strong>下输入<code>gdb-multiarch</code> ,出现<code>0x0000000000001000 in ?? ()</code>代表成功</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file kernel/kernel //加载kernel  或者 file user/_ls</span><br><span class="line"> </span><br><span class="line">b main //设置断点</span><br><span class="line">c //运行程序</span><br></pre></td></tr></table></figure> <img src="/posts/8a8374bd/%E8%B0%83%E8%AF%95.png" class="" title="image-20240419135611892"></li></ol><h3 id="调试指令"><a href="#调试指令" class="headerlink" title="调试指令"></a>调试指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">step 一次运行一行代码。当有函数调用时，它将步进到被调用的对象函数。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next 也是一次运行一行代码。但当有函数调用时，它不会进入该函数。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stepi </span><br><span class="line">nexti</span><br><span class="line">对于汇编指令是单步调试。</span><br></pre></td></tr></table></figure><p>所有命令都可以采用一个数字参数来指定重复执行的次数。按回车键将重复上一个命令。<br><code>layout src</code> 产看原代码<br><code>layout asm</code>：查看汇编<br><code>layout reg</code>：查看寄存器<br><code>info reg</code>：查看寄存器<br><code>info frame</code> 看到有关当前Stack Frame许多有用的信息<br><code>b *0x1234</code>：在指定地址设定断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i args  : 查看当前函数的入参</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i locals   : 查看局部变量</span><br></pre></td></tr></table></figure><p><code>continue</code>继续运行程序直到断点<br><code>info b</code> 查看断点<br><code>delete</code> 删除所有断点<br><code>d 1</code> 删除断点1<br><code>bt backtrace</code> 回溯程序运行顺序<br><code>watch i</code> 监视变量i当其发生变化时停下<br><code>p *args</code> 输出指针的值<br><code>p *args@2</code> 输出数组前两个值<br><code>b sum if i==5</code> 设置条件断点</p><h3 id="实际遇到的问题"><a href="#实际遇到的问题" class="headerlink" title="实际遇到的问题"></a>实际遇到的问题</h3><p>在实际情况下，使用gdb调试涉及内核的代码并不是很方便，在用户态下使用stepi 调试程序，内核态的发生过程对于用户态是透明的。</p><p>我们需要在进入内核态前使用<code>file kernel/kernel</code>加载内核，再使用stepi进入内核</p><p>进入内核后，系统会 调用 进程替换、中断函数、usertrap函数等保证系统的正常运行但是与我们的用户态程序直接关系不大的代码，使用stepi太繁琐，使用断点需要我们提前知道内核哪里发生了崩溃，使用gdb调试效率不高</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>进行实验时，我们需要在自己修改的代码后，增加足够多的<strong>printf</strong>函数，这样我们可以跟踪系统的执行情况。</p><p>在修改内核时，对自己的修改应拥有充分的理解，发生错误时，回滚至正常的版本，一步一步根据自己的代码进行修改，直到错误的出现，定位问题。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT6.S081 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园网环境下设置IPV6地址</title>
      <link href="/posts/f7219721.html"/>
      <url>/posts/f7219721.html</url>
      
        <content type="html"><![CDATA[<h2 id="校园网环境下设置IPV6地址"><a href="#校园网环境下设置IPV6地址" class="headerlink" title="校园网环境下设置IPV6地址"></a>校园网环境下设置IPV6地址</h2><p>​最近换了一个WR30U路由器，并刷入了OPENWRT系统，之前苦于没有公网IPV4地址，无法将群晖放在外网进行远程访问。本次打算为主机设置一个IPV6地址。</p><p>​<strong>本篇文章主要是为了记录设置IPV6的过程中出现的实际情况与网络教程不同的解决方法</strong></p><h3 id="一、路由器获取IPV6地址"><a href="#一、路由器获取IPV6地址" class="headerlink" title="一、路由器获取IPV6地址"></a>一、路由器获取IPV6地址</h3><p>​通过简单的设置获取IPV6地址，没有什么好讲的。</p><img src="/posts/f7219721/IPV6%E8%AE%BE%E7%BD%AE.png" class="" title="image-20231125173006252"><img src="/posts/f7219721/%E8%8E%B7%E5%8F%96IPV6.png" class="" title="image-20231125172747805"><p>​分析我们获得的IPV6地址发现学校下发的IPV6地址没有<code>ipv6-pd</code>的存在,说明<strong>无法在路由器下方划分子网,只能使用中继方式</strong></p><h3 id="二、设置IPV6下发模式"><a href="#二、设置IPV6下发模式" class="headerlink" title="二、设置IPV6下发模式"></a>二、设置IPV6下发模式</h3><h4 id="网上教程"><a href="#网上教程" class="headerlink" title="网上教程"></a>网上教程</h4><p>​根据网上的教程，在我们设置IPV6的时候，需要我们：</p><p>​1.将WAN6口-&gt;DHCP服务器-&gt;IPv6设置中的路由通告服务(RA服务)、DHCPv6服务、NDP代理改为中继模式，并指定其为主接口。</p><p>​2.LAN口同样也是将三项目改为中继模式<em>（LAN口不需要设置为IPV6 DHCP指定的主接口）</em>。</p><img src="/posts/f7219721/WAN%E8%AE%BE%E7%BD%AE.png" class="" title="image-20231125174255019"><img src="/posts/f7219721/%E6%8E%A5%E5%8F%A3ipv6%E8%AE%BE%E7%BD%AE.png" class="" title="image-20231125174409454"><h4 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h4><p>​实际上由于OPENWRT版本的不同，我只能找到LAN口设置DHCP-&gt;IPV6设置下，路由通告服务(RA服务)、DHCPv6服务、NDP代理。而WAN6口与WAN口始终无法找到相关选项。</p><img src="/posts/f7219721/%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5.png" class="" title="image-20231125175043534"><h4 id="解决方法：无敌的控制台"><a href="#解决方法：无敌的控制台" class="headerlink" title="解决方法：无敌的控制台"></a>解决方法：无敌的控制台</h4><p><strong>经过查找资料以及实践发现，我们可以通过直接修改内部文件的方式实现同样设置WAN口的三种模式为中继模式的效果。</strong></p><p>​1.通过openwrt图形界面将LAN口的三种模式设置为中继模式，<strong>不要将LAN设置为主接口</strong></p><p>​2.通过ssh连接至路由器后台，通过<code>vim /etc/config/dhcp</code>修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config dhcp &#x27;wan&#x27;</span><br><span class="line">option interface &#x27;wan&#x27;</span><br><span class="line">option ignore &#x27;1&#x27;</span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config dhcp &#x27;wan&#x27;</span><br><span class="line">option interface &#x27;wan&#x27;</span><br><span class="line">option ignore &#x27;1&#x27;</span><br><span class="line">option ra &#x27;relay&#x27;</span><br><span class="line">option dhcpv6 &#x27;relay&#x27;</span><br><span class="line">option ndp &#x27;relay&#x27;</span><br><span class="line">option master &#x27;1&#x27;</span><br></pre></td></tr></table></figure><p>ra,dhcpv6,ndp对应路由通告服务(RA服务)、DHCPv6服务、NDP代理。而option master ‘1’ 对应指定的主接口这一选项。</p><p>重启路由器与PC，通过<a href="https://www.test-ipv6.com/">ipv6测试网站</a>检查是否成功，示意图如下</p><img src="/posts/f7219721/IPv6%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png" class="" title="image-20231125180102335"><p>参考文章：</p><p>​1.<a href="https://post.smzdm.com/p/awzodmpp/?sort_tab=hot/">OpenWRT 路由器IPv6实战配置长篇教程：纠正你的IPv4思维！</a></p><p>​2.<a href="https://www.right.com.cn/forum/thread-8309440-1-1.html">终于Openwrt设置ipv6教程 100%成功，研究数日无偿分享</a></p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园网 </tag>
            
            <tag> ipv6 </tag>
            
            <tag> OpenWrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群晖NAS的qbittorrent套件版本切换至docker版本</title>
      <link href="/posts/b489d982.html"/>
      <url>/posts/b489d982.html</url>
      
        <content type="html"><![CDATA[<h2 id="群晖NAS的qbittorrent套件版本切换至docker版本"><a href="#群晖NAS的qbittorrent套件版本切换至docker版本" class="headerlink" title="群晖NAS的qbittorrent套件版本切换至docker版本"></a>群晖NAS的qbittorrent套件版本切换至docker版本</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>1.之前使用套件版本的qbittorrent进行种子的下载，发现qbittorrent经常性的卡死，遂决定转至docker版本的qbittorrent</p><img src="/posts/b489d982/qbittorrent.png" class="" title="image-20231021160034283"><p>2.希望能够迁移的过程中保留之前正在下载的进程以及已经下载好的种子</p><h3 id="一-进行dockers版本的安装"><a href="#一-进行dockers版本的安装" class="headerlink" title="一.进行dockers版本的安装"></a>一.进行dockers版本的安装</h3><p>1.搜索注册表进行安装</p><img src="/posts/b489d982/%E6%90%9C%E7%B4%A2%E6%B3%A8%E5%86%8C%E8%A1%A8.png" class="" title="image-20231021143646007"><p>2.设置好端口映射关系</p><img src="/posts/b489d982/%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84.png" class="" title="image-20231021143907719"><p>容器默认设置的8080端口为webui的默认端口，我们需要将其固定为指定的端口，这里我们设置为8086.</p><img src="/posts/b489d982/%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%842.png" class="" title="image-20231021144029815"><p>3.设置文件映射关系</p><p>我们需要自己创建config文件，与downloads文件。</p><p>如果想要数据保留，<strong>downloads</strong>文件最好处于<strong>套件版本的qbittorrent的downloads文件</strong>的上层，即前者包含或等同于后者</p><img src="/posts/b489d982/%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84.png" class="" title="image-20231021144446920"><img src="/posts/b489d982/%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%842.png" class="" title="image-20231021144537791"><p>4.设置环境变量</p><p>在环境变量中新增以下环境变量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">PUID=1000</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">PGID=1000</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">WEBUI_PORT=8080</span></span><br></pre></td></tr></table></figure><img src="/posts/b489d982/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" class="" title="image-20231021145625368"><p><strong>注意此时的WEBUI_PORT</strong>依然设置为8080，我们之前设置的端口映射是将WEBUI_PORT映射至8086</p><h3 id="二、登录qbittorrent的WEBUI"><a href="#二、登录qbittorrent的WEBUI" class="headerlink" title="二、登录qbittorrent的WEBUI"></a>二、登录qbittorrent的WEBUI</h3><p>在本地计算器的浏览器中输入地址:<a href="http://nasip:8086/%E5%9C%B0%E5%9D%80:8086/">http://NASIP:8086/地址:8086/</a> <em>(例如<a href="http://192.168.10.13:8086/">http://192.168.10.13:8086/</a>)</em></p><p>如果看到提示用户名和密码说明登录成功,默认用户名admin，默认密码adminadmin</p><img src="/posts/b489d982/WebUi.png" class="" title="image-20231021150108313"><p>如果看到<strong>Unauthorized</strong>的提醒</p><p>我们需要将&#x2F;config&#x2F;qBittorrent&#x2F;qBittorrent.conf中的<code>WebUI\HostHeaderValidation=true</code></p><p>修改为<code>WebUI\HostHeaderValidation=false</code>如果没有则添加上。</p><p><em><a href="https://github.com/qbittorrent/qBittorrent/issues/8095#issuecomment-472740702">问题解决参考</a></em></p><h3 id="二、进行套件向docker的数据迁移，不迁移请无视"><a href="#二、进行套件向docker的数据迁移，不迁移请无视" class="headerlink" title="二、进行套件向docker的数据迁移，不迁移请无视"></a>二、进行套件向docker的数据迁移，不迁移请无视</h3><p>1.这里需要我们利用ssh对NAS进行操作，<strong>利用<code>sudo -i</code>指令进行root模式后</strong>，我们可以使用<code>ps -aux |grep qb</code>指令，（该指令的意义是列出系统所有进程，并过滤出名称中含有qb的进程）</p><img src="/posts/b489d982/%E6%90%9C%E7%B4%A2qb%E7%9A%84%E6%89%80%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9.png" class="" title="image-20231021151203450"><p>2.可以看出套件版本的qBittorrent所处的大致位置，进入qBittorrent文件夹，<code>ls</code>列出文件结构，进入qBittorrent_conf目录</p><p>3.利用<code>cp -r 原目录 去往目录</code>指令，复制<strong>套件config目录到docker中的config目录</strong></p><p>4.利用<code>chown -R 1000:1000 config</code>指令将复制好的目录的拥有人pid和puid都改为1000（与docker容器环境变量一致），防止出现权限问题。</p><p>5.同理复制授权<strong>套件目录qBittorrent&#x2F;data&#x2F;BT_backup</strong>，该文件夹存储的是套件的种子信息。图片为docker的目标目录。</p><img src="/posts/b489d982/docker%E7%9A%84%E7%9B%AE%E6%A0%87%E7%9B%AE%E5%BD%95.png" class="" title="image-20231021152224233"><p>6.重启docker的qbittorrent容器，登录WEBUI，此时大部分种子都提示为丢失文件状态</p><img src="/posts/b489d982/%E7%A7%8D%E5%AD%90%E4%B8%A2%E5%A4%B1.png" class="" title="image-20231021152530855"><p>7.右键丢失文件的种子，选择更改保存位置，将保存位置修改为原文件现在所处的相对于容器（docker 版本qbittorrent）映射位置</p><img src="/posts/b489d982/%E7%A7%8D%E5%AD%90%E4%B8%A2%E5%A4%B12.png" class="" title="image-20231021152647572"><p>例如，我套件下载好的动漫原本所处位置为&#x2F;volume1&#x2F;video&#x2F;download&#x2F;动漫</p><p>我进行映射时，将&#x2F;volume1&#x2F;video&#x2F;download&#x2F; 映射为&#x2F;downloads 目录，那么我需要修改保存位置为&#x2F;downloads&#x2F;动漫 就可以了</p><img src="/posts/b489d982/%E7%A7%8D%E5%AD%90%E4%B8%A2%E5%A4%B13.png" class="" title="image-20231021153050982"><img src="/posts/b489d982/%E7%A7%8D%E5%AD%90%E6%81%A2%E5%A4%8D.png" class="" title="image-20231021153057116">]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> 群晖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表相关算法</title>
      <link href="/posts/6799903a.html"/>
      <url>/posts/6799903a.html</url>
      
        <content type="html"><![CDATA[<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">题目链接</a></p><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p>示例 1:</p><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true<br>示例 2:</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false</p></blockquote><h3 id="数组哈希"><a href="#数组哈希" class="headerlink" title="数组哈希"></a>数组哈希</h3><p>字母的范围从a到b只有26个，可以使用数组来实现哈希表，扫描s并记录每一个字母的出现频率，扫描t进行比较</p><p><strong>注意：</strong>统计字母出现频率的数组需要进行初始化，否则在进行判断时会出错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool isAnagram(string s, string t)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.length() != t.length())//长度不等必然不符合条件</span><br><span class="line">        return false;</span><br><span class="line">    int a[26] = &#123;0&#125;;</span><br><span class="line">    for (auto i : s)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i - &#x27;a&#x27;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto i : t)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a[i - &#x27;a&#x27;] &gt; 0)</span><br><span class="line">            a[i - &#x27;a&#x27;]--;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">题目链接</a></p><blockquote><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p><p> 示例 1：</p><p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]<br>示例 2：</p><p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的</p></blockquote><h3 id="使用unordered-set"><a href="#使用unordered-set" class="headerlink" title="使用unordered_set"></a>使用unordered_set</h3><p><strong>思路</strong></p><p>​要求输出的结果中每一个元素时唯一的且不要求顺序，考虑使用unordered_set</p><p>​先将一个数组初始化unordered_set，比较另一个数组中的每一个元素是否存在于set，如果存在则放入一个unordered_map，由于其特性，他会自动去除重复的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">uset</span><span class="params">(nums1.begin(), nums1.end())</span></span>;<span class="comment">//将nums1初始化unordered_set</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (uset.<span class="built_in">find</span>(i) != uset.<span class="built_in">end</span>())<span class="comment">//uset.find(i) == uset.end()  代表没有找到这个元素</span></span><br><span class="line">            res.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());<span class="comment">//将unordered_set转化为vector格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第202题-快乐数"><a href="#第202题-快乐数" class="headerlink" title="第202题. 快乐数"></a>第202题. 快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">题目链接</a></p><blockquote><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p><p>示例 1：</p><p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1<br>示例 2：</p><p>输入：n &#x3D; 2<br>输出：false</p></blockquote><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>在重复进行替换正整数的过程中，只会出现两个结果：进入无限循环；或者结果为1</p><p>而当相同的数字出现两次及以上的时候，说明这个过程<strong>进入了无限循环</strong>。我们以此为依据，建立一个哈希表</p><p>将每次替换后的数字在哈希表中查找，如果曾经出现过，说明进入了无限循环，这个数不是快乐数；如果没有出现过，我们将数字录入哈希表中，再次进行替换过程，直至替换结果为1（快乐数）或者新数字在哈希表中出现（非快乐数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数字n替换为每个位置上数字的平方和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Change</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为快乐数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (uset.<span class="built_in">find</span>(n) != uset.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            uset.<span class="built_in">insert</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">Change</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">题目链接</a></p><blockquote><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p> 示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历nums数组，查找umap哈希中是否存在一个key恰好为target-nums[i]的元素，如果有则为答案，如果没有，则将遍历到的元素存入umap当中，<strong>注意：umap存入元素时，key值设为元素的值的大小，value设置为元素的数组下标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (umap.<span class="built_in">find</span>(target - nums[i]) != umap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;umap[target - nums[i]], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            umap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="454-四数相加"><a href="#454-四数相加" class="headerlink" title="454.四数相加"></a>454.四数相加</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">题目链接</a></p><blockquote><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><p>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]<br>输出：2<br>解释：<br>两个元组如下：</p><ol><li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li><li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0<br>示例 2：</li></ol><p>输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]<br>输出：1</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题与<em>1.两数之和</em>的思路相似，只需要将前两个数组看成一部分，后两个数组看成另一部分，就可以拆解为两数之和的问题，进行求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2, vector&lt;<span class="type">int</span>&gt; &amp;nums3, vector&lt;<span class="type">int</span>&gt; &amp;nums4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; sum;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums1)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i + j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums3)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : nums4)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = i + j;</span><br><span class="line">            <span class="keyword">auto</span> it = sum.<span class="built_in">find</span>(-temp);</span><br><span class="line">            <span class="keyword">if</span> (it != sum.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cnt += it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">题目链接</a></p><blockquote><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><p> 示例 1：</p><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false<br>示例 2：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false<br>示例 3：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>与242.有效的字母异位词相似，不同的是ransomNote中的所有字母都在magazine存在即可，不需要后者的字母都在前者中存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : magazine)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[i - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ransomNote)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[i - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">题目链接</a></p><blockquote><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请</p><p>你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组</p><p> 示例 1：</p><p> 输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。<br>示例 3：</p><p>输入：nums &#x3D; [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。</p></blockquote><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>这道题的哈希解法比较困难，去重逻辑较为复杂,使用双指针法进行求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//先对nums进行排序，使相同的数字排列在一起，为之后的去重做好准备</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 排序后最小的数大于0，无论如何都无法三个数相加等于零</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// i去重,去除两个连续的相同i的情况</span></span><br><span class="line">        <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 去重，防止left与之前的相同</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每次移动都检查会浪费时间</span></span><br><span class="line">                right--;</span><br><span class="line">                <span class="comment">/* while (left &lt; right)</span></span><br><span class="line"><span class="comment">                 &#123;</span></span><br><span class="line"><span class="comment">                     if (nums[right] == nums[right + 1])</span></span><br><span class="line"><span class="comment">                         right--;</span></span><br><span class="line"><span class="comment">                     else</span></span><br><span class="line"><span class="comment">                         break;</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每次移动都检查会浪费时间</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">/* while (left &lt; right)</span></span><br><span class="line"><span class="comment">                 &#123;</span></span><br><span class="line"><span class="comment">                     if (nums[left] == nums[left - 1])</span></span><br><span class="line"><span class="comment">                         left++;</span></span><br><span class="line"><span class="comment">                     else</span></span><br><span class="line"><span class="comment">                         break;</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1-基于范围的for循环（C-11"><a href="#1-基于范围的for循环（C-11" class="headerlink" title="1.基于范围的for循环（C++ 11 )"></a>1.基于范围的for循环（C++ 11 )</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : nums)</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>该循环可以显示数组的每一个值，但是<strong>无法通过这种方法对元素进行修改</strong><br>需要使用<strong>引用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> &amp;x : nums)</span><br><span class="line">x=x*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>基于范围的for循环与迭代器遍历的不同：<br>    for循环返回元素<br>    迭代器为指针<br>例如：遍历map</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果it为基于范围的for循环</span><br><span class="line">for(auto it:umap)</span><br><span class="line">key = it.first</span><br><span class="line">value=it.second</span><br><span class="line">如果it为迭代器</span><br><span class="line">for(auto it=umap.begin();it!=umap.end();it++)</span><br><span class="line">key=it-&gt;first</span><br><span class="line">value=it-&gt;second</span><br></pre></td></tr></table></figure><h3 id="2-C-三个set的区别"><a href="#2-C-三个set的区别" class="headerlink" title="2.C++三个set的区别"></a>2.C++三个<strong>set</strong>的区别</h3><h4 id="三个set分别为set-unordered-set-multiset"><a href="#三个set分别为set-unordered-set-multiset" class="headerlink" title="三个set分别为set,unordered_set,multiset"></a>三个set分别为set,unordered_set,multiset</h4><p>1、unordered_set的底层实现是通过<strong>哈希表</strong>的方式实现的<br>2、set和multiset的底层是通过<strong>红黑树</strong>实现的***(红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。)***</p><p>3.集合来解决哈希问题的时候，<strong>优先</strong>使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是<strong>有序</strong>的，那么就用set，如果要求不仅有序还要有<strong>重复数据</strong>的话，那么就用multiset。</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h3 id="3-C-三个map的区别"><a href="#3-C-三个map的区别" class="headerlink" title="3.C++三个map的区别"></a>3.C++三个map的区别</h3><h4 id="三个map分别为map，multimap，unordered-map"><a href="#三个map分别为map，multimap，unordered-map" class="headerlink" title="三个map分别为map，multimap，unordered_map"></a>三个map分别为map，multimap，unordered_map</h4><p>1.unordered_map的底层实现是通过<strong>哈希表</strong>的方式实现的</p><p>2.map，multimap底层是通过<strong>红黑树</strong>实现的***(红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。)***</p><p>3.map可以修改value值，不可以修改key值</p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h3 id="4-去除vector中的重复元素"><a href="#4-去除vector中的重复元素" class="headerlink" title="4.去除vector中的重复元素"></a>4.去除vector中的重复元素</h3><h4 id="1-vector-lt-int-gt-类型"><a href="#1-vector-lt-int-gt-类型" class="headerlink" title="1.vector&lt;int&gt; 类型"></a>1.<code>vector&lt;int&gt;</code> 类型</h4><p>可以利用<code>unordered_set</code>不存储重复key值的特性，先将vector转化为set，再转化回来</p><h4 id="2-vector-lt-vector-lt-int-gt-gt-类型"><a href="#2-vector-lt-vector-lt-int-gt-gt-类型" class="headerlink" title="2.vector&lt;vector&lt;int&gt;&gt; 类型"></a>2.<code>vector&lt;vector&lt;int&gt;&gt;</code> 类型</h4><p>因为unordered_set<strong>底层通过哈希方法实现</strong>对key值的查找，而C++没有为vector提供默认的哈希方法，导致第一种方法失效。<br><strong>所以我们需要利用unique函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(res.begin(), res.end());</span><br><span class="line">auto it=unique(res.begin(), res.end());</span><br><span class="line">res.erase(it,res.end());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群晖的基础玩法</title>
      <link href="/posts/626b2962.html"/>
      <url>/posts/626b2962.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-利用cloud-sync进行数据备份"><a href="#1-利用cloud-sync进行数据备份" class="headerlink" title="1.利用cloud sync进行数据备份"></a>1.利用cloud sync进行数据备份</h2><p><strong>数据安全</strong>是NAS用户应该给予重视的问题，我们可以使用套件Cloud sync将重要数据加密上传到百度网盘上，即使数据损坏，也可以从网盘上恢复</p><p>注意：cloud sync中百度网盘的上传文件大小有限制，稍微大一些的文件需要分卷压缩进行上传。</p><p>双向备份可以使NAS和百度网盘的文件保持一致，并且可以将百度网盘的文件移动到NAS文件夹实现下载的目的，但是本人体验时发现对文件进行短时间的频繁变动<em>（例如从NAS向百度网盘上传12集番剧，上传途中改变了本地动漫的名称，可能导致某一集存在两个版本）</em>，可能导致备份混乱，重复上传。</p><p><strong>在进行备份时，百度网盘的设置最好不要设置为根目录</strong>，否则之后无法添加其他文件夹进行备份。</p><h2 id="2-利用Driver实现NAS与个人PC文件夹的同步"><a href="#2-利用Driver实现NAS与个人PC文件夹的同步" class="headerlink" title="2.利用Driver实现NAS与个人PC文件夹的同步"></a>2.利用Driver实现NAS与个人PC文件夹的同步</h2><p>本人的NAS运行于校园网环境，晚上宿舍断电之后经常会面临连接不上NAS的情况，倘若将常用的数据存在于NAS当中，经常会在需要的时候无法使用。而我们可以是使用Drive套件，将PC上某一文件夹指定为同步目录，在NAS可以连接的时候，PC的文件会自动同步至NAS，断电后即使我们对共享文件夹进行了变动，也可以在NAS来电后自动同步。</p><img src="/posts/626b2962/Drive.png" class="" title="image-20230508132036191"><h2 id="3-群晖助手"><a href="#3-群晖助手" class="headerlink" title="3.群晖助手"></a>3.群晖助手</h2><p>群晖助手是一位大佬开发的针对于群晖NAS的远端控制软件，结合Tailscale可以实现在局域网外对NAS进行如关闭SSH功能，重启，观看视频的操作，该软件在apple store 上的名称叫做派派助手。</p><img src="/posts/626b2962/%E7%BE%A4%E6%99%96%E5%8A%A9%E6%89%8B.png" class="" title="image-20230508133716969"><h2 id="4-Moments-进行照片管理"><a href="#4-Moments-进行照片管理" class="headerlink" title="4.Moments 进行照片管理"></a>4.Moments 进行照片管理</h2><img src="/posts/626b2962/Moments.png" class="" title="image-20230508134101449"><p>Moment是群晖自带的管理照片的套件（918+版本），谷歌商店与apple store均有软件，我们可以将自己的照片上传到Moment，他会自动根据人脸，地点进行分类，我们可以在ipad，手机，pc等多端进行查看，也可以为家庭设置共享相册。</p><img src="/posts/626b2962/%E5%85%B1%E4%BA%AB%E7%9B%B8%E5%86%8C.png" class="" title="image-20230508134407319"><h2 id="5-下载openwrt将群晖作为旁路由使用"><a href="#5-下载openwrt将群晖作为旁路由使用" class="headerlink" title="5.下载openwrt将群晖作为旁路由使用"></a>5.下载openwrt将群晖作为旁路由使用</h2><p>单网口的群晖可以在Docker或者Virtual Machine Manager中安装openwrt，这样我们可以将群晖作为旁路由使用。openwrt可以干什么请自行了解（doge）</p><h2 id="6-RSS订阅"><a href="#6-RSS订阅" class="headerlink" title="6.RSS订阅"></a>6.RSS订阅</h2><p>在RSS订阅时，倘若站点本身无法直接连接，需要使用魔法时，我们可以安装openwrt，使用其中的open clash插件，如果希望种子文件（bt）下载时不占用机场流量，可以在open clash设置中屏蔽下载器的端口号（例如qbittorrent的端口号为8085）。</p><h2 id="7-FTP服务将文件分享给别人"><a href="#7-FTP服务将文件分享给别人" class="headerlink" title="7. FTP服务将文件分享给别人"></a>7. FTP服务将文件分享给别人</h2><p>假如我们需要将文件分享给别人，群晖可以支持FTP服务（处于同一个网络下，例如校园网）。</p><p>步骤：</p><ol><li><p>打开路由器的DMZ端口设置，具体步骤见上篇文章<a href="https://www.shui2000.top/posts/1dafad22.html">校园网环境下访问群晖NAS</a></p></li><li><p>设置一个ftp专用的共享文件夹与专用账号。<strong>注意权限不要给太高，最好只给共享文件的读写权限</strong></p></li><li><p>在控制面板中的文件服务中进行ftp的设置，<strong>推荐在高级设置中将账号的根目录设置到ftp专用的共享文件夹</strong></p><img src="/posts/626b2962/FTP%E8%AE%BE%E7%BD%AE.png" class="" title="image-20230508140355430"><img src="/posts/626b2962/FTP%E8%AE%BE%E7%BD%AE2.png" class="" title="image-20230508140437754"></li><li><p>将路由器的ip地址告诉给同学，即可以进行愉快的ftp文件分享。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> 群晖 </tag>
            
            <tag> 校园网 </tag>
            
            <tag> Tailscale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表相关算法</title>
      <link href="/posts/db79b42f.html"/>
      <url>/posts/db79b42f.html</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>链表的使用中<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了</li><li>链表的使用要注意使用p&#x3D;p-&gt;next;因为p为nullptr时，p-&gt;next会造成内存溢出</li><li>注意移除链表元素后删除元素，回收空间</li></ol><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">题目链接</a></p><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><img src="/posts/db79b42f/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.png" class="" title="image-20230414213413695"><p>示例 1：<br>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]<br>示例 2：<br>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]<br>示例 3：<br>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">ListNode *<span class="title">removeElements</span><span class="params">(ListNode *head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *L = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    L-&gt;next = head;<span class="comment">//使用头节点可以让</span></span><br><span class="line">    ListNode *p = L;</span><br><span class="line">    ListNode *q;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            q=p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;<span class="comment">//删除元素回收空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">链接</a></p><blockquote><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p><p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p><p>输入：head &#x3D; []<br>输出：[]</p></blockquote><h3 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h3><p>遍历整个链表，基于<strong>头插法</strong>的思想重新构建链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *L =<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    ListNode *p =<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    ListNode *q =<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>利用双指针，遍历修改，例如 原本节点的关系为 pre-&gt;cur 双指针修改为 pre&lt;-cur</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        ListNode *temp=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;<span class="comment">//最后cur指向了空指针，pre指向了原本的最后一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">题目链接</a></p><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p><p>输入：head &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [1]<br>输出：[1]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *L = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    L-&gt;next = head;</span><br><span class="line">    ListNode *cur = L-&gt;next;</span><br><span class="line">    ListNode *pre = L;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *temp = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="comment">// 此时 temp-&gt;pre-&gt;cur-&gt;nullptr</span></span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        temp-&gt;next = cur;</span><br><span class="line">        <span class="comment">// 此时 temp-&gt;cur-&gt;pre</span></span><br><span class="line"></span><br><span class="line">        cur = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目链接</a></p><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：一次扫描实现</strong></p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p><p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]</p></blockquote><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>思路：要求删除第n个节点，那么设置快慢两个指针，二者相差为n+1，同时遍历，当快指针遍历完时，慢指针即为倒数第n-1个节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *L = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    L-&gt;next = head;</span><br><span class="line">    ListNode *fast = L;</span><br><span class="line">    ListNode *slow = L;</span><br><span class="line">    <span class="type">int</span> num = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = fast-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> fast;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">题目链接</a></p><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><img src="/posts/db79b42f/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.png" class="" title="image-20230419214921678"><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>示例 1：</p><img src="/posts/db79b42f/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%A4%BA%E4%BE%8B1.png" class="" title="image-20230419214951242"><p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>示例 2：</p><img src="/posts/db79b42f/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%A4%BA%E4%BE%8B2.png" class="" title="image-20230419215009981"><p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br>示例 3：</p><img src="/posts/db79b42f/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%A4%BA%E4%BE%8B3.png" class="" title="image-20230419215018099"><p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以计算出两个链表的长度，然后每个链表都有一个对应的指针，使指向的节点到链表末尾的链表长度相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numa = <span class="number">0</span>, numb = <span class="number">0</span>;</span><br><span class="line">    ListNode *p = headA;</span><br><span class="line">    ListNode *q = headB;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        numa++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q)</span><br><span class="line">    &#123;</span><br><span class="line">        numb++;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = headA;</span><br><span class="line">    q = headB;</span><br><span class="line">    <span class="keyword">if</span> (numa &gt; numb)</span><br><span class="line">    &#123;</span><br><span class="line">        length = numa - numb;</span><br><span class="line">        <span class="keyword">while</span> (length)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        length = numb - numa;</span><br><span class="line">        <span class="keyword">while</span> (length)</span><br><span class="line">        &#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="142-环形链表-Ⅱ"><a href="#142-环形链表-Ⅱ" class="headerlink" title="142.环形链表 Ⅱ"></a>142.环形链表 Ⅱ</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">题目链接</a></p><blockquote><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果链表存在环，那么设定一个每次行走2个节点的fast指针，一个每次行走1个节点的slow指针，这两个指针速度相差1，那么指针一定会在循环链表中相遇<em>（操场跑步的时候，时间一直走，速度快的人一定会和速度慢的人相遇（套圈））</em></p><p>根据推导，我们可以看出如果重新设定一个从head节点出发的指针，一个从fast和slow节点相遇的结点出发的指针，两个指针的移动速度相同，他们<strong>一定会在环的入口处相遇</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ListNode *detectCycle(ListNode *head)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    while (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if (fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            while (fast != slow)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            return fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组相关算法</title>
      <link href="/posts/63798680.html"/>
      <url>/posts/63798680.html</url>
      
        <content type="html"><![CDATA[<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><p><a href="https://leetcode.cn/problems/binary-search/">题目链接</a></p><blockquote><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。<br>示例 1:</p><p>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p><p>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        m=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m]==target)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[m]&gt;target)</span><br><span class="line">            r=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l=m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">题目链接</a></p><blockquote><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>​说明:</p><p>​为什么返回数值是整数，但输出的答案是数组呢?</p><p>​请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>​你可以想象内部操作如下:</p><p>​&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>​int len &#x3D; removeElement(nums, val);</p><p>​&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。<br>​&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>​for (int i &#x3D; 0; i &lt; len; i++) {<br>   ​print(nums[i]);<br>​}</p><p>示例 1：</p><p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>设置快指针fast,与慢指针slow,快指针检测到符合要求（不等于val）的值，则赋值给下标为slow的元素，<strong>slow同时可以表示符合要求的值的个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt; &amp;nums, int val)</span><br><span class="line">&#123;</span><br><span class="line">    int fast=0;</span><br><span class="line">    int slow=0;</span><br><span class="line">    for(fast=0;fast&lt;nums.size();fast++)&#123;</span><br><span class="line">        if(nums[fast]!=val)&#123;</span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="997-有序数组的平方"><a href="#997-有序数组的平方" class="headerlink" title="997.有序数组的平方"></a>997.有序数组的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">题目链接</a></p><blockquote><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p>示例 1：</p><p>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]<br>示例 2：</p><p>输入：nums &#x3D; [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p></blockquote><h3 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h3><p>经过观察，可以发现nums每个数取平方后，是两边大中间小的，可以用双指针法从两边向中间逐渐逼近，每次比较将大数值放在新数组的后面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; sortedSquares(vector&lt;int&gt; &amp;nums)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    res.resize(nums.size());</span><br><span class="line">    int left=0;</span><br><span class="line">    int right=nums.size()-1;</span><br><span class="line">    int i=nums.size()-1;</span><br><span class="line">    while(left&lt;=right)&#123;</span><br><span class="line">        int ll=nums[left]*nums[left];</span><br><span class="line">        int rr=nums[right]*nums[right];</span><br><span class="line">        if(ll&gt;rr)&#123;</span><br><span class="line">            res[i]=ll;</span><br><span class="line">            i--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res[i]=rr;</span><br><span class="line">            i--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum">链接</a></p><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>​示例 1：</p><p>​输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>​输出：2<br>​解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>​示例 2：</p><p>​输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>​输出：1<br>​示例 3：</p><p>​输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>​输出：0</p></blockquote><h3 id="滑动窗口法（双指针法）"><a href="#滑动窗口法（双指针法）" class="headerlink" title="滑动窗口法（双指针法）"></a>滑动窗口法（双指针法）</h3><p>slow与fast之间的序列即为子序列，当子序列的和小于target时，移动fast指针使序列和增加，当子序列的和大于等于target时，不断移动slow指针使子序列长度缩减</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fast=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min=nums.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(fast=<span class="number">0</span>;fast&lt;nums.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">        sum+=nums[fast];</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">            <span class="type">int</span> length=fast-slow+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(min&gt;length)</span><br><span class="line">                min=length;</span><br><span class="line">            sum-=nums[slow];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(min==nums.<span class="built_in">size</span>()+<span class="number">1</span>)<span class="comment">//说明没有符合要求的子序列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">题目链接</a></p><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：n = 3</span><br><span class="line">&gt;输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：n = 1</span><br><span class="line">&gt;输出：[[1]]</span><br></pre></td></tr></table></figure></blockquote><p>本题不涉及特殊算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    res.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res[i].<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, bottom = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n*n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt;= right; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[top][j] = i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = top; j &lt;= bottom; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[j][right] = i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = right; j &gt;= left; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            res[bottom][j] = i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = bottom; j &gt;= top; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            res[j][left] = i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园网环境下访问群晖NAS</title>
      <link href="/posts/1dafad22.html"/>
      <url>/posts/1dafad22.html</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h2><ol><li><p>连接网络；群晖本身是不能够连接显示屏进行使用的，需要我们知道IP地址，在同一个局域网的电脑上登陆操作，</p><p>但本人所在的校园网需要使用web进行网页认证<em>（深澜校园网）</em>，所以我们<strong>需要一个路由器</strong>，通过路由器认证校园网，然后连接群晖的方式将其接入网络。</p><img src="/posts/1dafad22/%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%AE%A4%E8%AF%81.png" class="" title="image-20230407161913014"></li><li><p>外部访问；由于我们使用路由器连接群晖，导致群晖本身处于校园网更下层的一个局域网中，同在一个校园网中的设备无法直接访问群晖，我准备了两种方式来解决这个问题：DMZ端口转发与Tailscale连接。</p></li><li><p>宿舍晚上断电，无解，或者去把厕所灯偷偷接到宿舍里,实现宿舍不断电<img src="/posts/1dafad22/huaji.jpg" class="" title="huaji15"></p></li></ol><h2 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h2><p>电脑一台，路由器一个（本人用的E2633），网线两根（一根连接校园网，一根连接群晖）</p><h2 id="连接群晖"><a href="#连接群晖" class="headerlink" title="连接群晖"></a>连接群晖</h2><p>​<strong>在路由器连接校园网的时候，要先查资料再行动，如果路由器配置不当，可能导致整个宿舍楼断网</strong></p><p>​路由器E2633本身支持的网络认证方式有PPPOE拨号连接，DHCP连接，桥接模式，Mesh组网</p><p>​经过尝试，我选择使用了DHCP连接的方式。</p><blockquote><p>E2633的DHCP连接方式本身存在BUG，如果我们在重置路由器后，在引导向导里面选择DHCP连接方式后，随后WIFI是没有网的，而且我们选择修改WIFI名称也没有作用，（当时我差点把货退了）<br>所以E2633需要在启动时先跳过向导，之后在上网设置后进行DHCP相关配置</p></blockquote><p>​将校园网网线接入到路由器<strong>WAN口</strong>当中，设置为路由器为<strong>自动获取DHCP</strong>模式，电脑或者手机连接到路由器WIFI后，输入校园网认证地址后进行认证，成功之后，其他设备（比如群晖）连接路由器不需要认证即可上网。但是如果宿舍网上断电，第二天需要重新认证。</p><p>将群晖接入路由器后，在路由器后台查看ip地址，即可连接。</p><blockquote><p><strong>注意：如果使用桥接模式，需要提前关闭自己路由器DHCP服务，再将网线接入到路由器LAN口当中</strong><br><strong>桥接模式先关DHCP自动下发！桥接模式先关DHCP自动下发！桥接模式先关DHCP自动下发！重要的事情说三遍！</strong></p><p>原因：<br>    桥接模式下如果不关路由器自身的DHCP服务，那么桥接后的网络中就会存在两个下发ip地址的路由器，当手机连接到WIFI后，分配到的ip地址如果是主路由器（学校的路由器）下发的ip地址，那么就可以正常上网，如果是从路由器（你的路由器）下发的ip地址，那么就无法上网，而且分配到哪个路由器下发的ip地址，全凭运气。</p></blockquote><h2 id="外部访问群晖"><a href="#外部访问群晖" class="headerlink" title="外部访问群晖"></a>外部访问群晖</h2><h3 id="方法一：DMZ端口转发"><a href="#方法一：DMZ端口转发" class="headerlink" title="方法一：DMZ端口转发"></a>方法一：DMZ端口转发</h3><h4 id="优点：设置简单，使用ftp服务与别人传文件比较方便"><a href="#优点：设置简单，使用ftp服务与别人传文件比较方便" class="headerlink" title="优点：设置简单，使用ftp服务与别人传文件比较方便"></a><strong>优点</strong>：设置简单，使用ftp服务与别人传文件比较方便</h4><h4 id="缺点：安全系数低，路由器的ip地址可能会变，只能在校园网中使用"><a href="#缺点：安全系数低，路由器的ip地址可能会变，只能在校园网中使用" class="headerlink" title="缺点：安全系数低，路由器的ip地址可能会变，只能在校园网中使用"></a><strong>缺点</strong>：安全系数低，路由器的ip地址可能会变，只能在校园网中使用</h4><p>​DMZ端口转发需要在路由器的DHCP中给群晖设置一个静态IP地址，并通过DMZ端口映射到校园网当中，这样只要知道路由器在校园网中的ip地址，访问路由器即可以访问到群晖系统。</p><p>​但是校园网一般都是DHCP下发IP地址的，一定时间内会根据MAC地址给同一设备分配相同的IP地址，但是这不是绝对的，IP地址仍可能会变</p><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><p>​1.进入路由器管理后台，给群晖NAS绑定一个静态IP地址，我这里绑定的是192.168.10.13</p><img src="/posts/1dafad22/%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A.png" class="" title="image-20230407152856475"><p>​2.设置DMZ端口转发<img src="/posts/1dafad22/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.png" class="" title="image-20230407152915840"></p><p>​3.通过访问路由器的ip地址即可以访问到群晖</p><h3 id="方法二：-Tailscale进行外网访问（推荐）"><a href="#方法二：-Tailscale进行外网访问（推荐）" class="headerlink" title="方法二： Tailscale进行外网访问（推荐）"></a>方法二： Tailscale进行外网访问（推荐）</h3><blockquote><p> What is Tailscale?</p><p>Tailscale is a VPN service that makes the devices and applications you own accessible anywhere in the world, securely and effortlessly. It enables encrypted point-to-point connections using the open source <a href="https://www.wireguard.com/">WireGuard</a> protocol, which means only devices on your private network can communicate with each other.</p><p>—- 摘录自<a href="https://tailscale.com/kb/1151/what-is-tailscale/">Tailscale官网</a></p><p>个人渣翻：</p><p>什么是Tailscale？</p><p>Tailscale是一个可以让你在世界任何一个角落安全高效地连接你所拥有的设备的VPN服务，它使用了 <a href="https://www.wireguard.com/">WireGuard</a> 开源协议实现了加密点对点连接，只有你的私人设备之间才能相互连接</p></blockquote><h5 id="优点：可以在校园网外连接群晖NAS，设置好后ip地址不会改变"><a href="#优点：可以在校园网外连接群晖NAS，设置好后ip地址不会改变" class="headerlink" title="优点：可以在校园网外连接群晖NAS，设置好后ip地址不会改变"></a><strong>优点</strong>：可以在校园网外连接群晖NAS，设置好后ip地址不会改变</h5><h5 id="缺点：设置比较繁琐（相较于方法一）"><a href="#缺点：设置比较繁琐（相较于方法一）" class="headerlink" title="缺点：设置比较繁琐（相较于方法一）"></a><strong>缺点</strong>：设置比较繁琐（相较于方法一）</h5><h5 id="操作步骤：-1"><a href="#操作步骤：-1" class="headerlink" title="操作步骤："></a>操作步骤：</h5><ol><li><p>进入Tailscale-synology的<a href="https://pkgs.tailscale.com/stable/#spks">官方源</a>下载SPK包，其他系统使用<a href="https://pkgs.tailscale.com/stable/">这个地址</a></p></li><li><p>在群晖套件中心安装spk包</p><img src="/posts/1dafad22/%E5%AE%89%E8%A3%85%E5%A5%97%E4%BB%B6.png" class="" title="image-20230407153624640"></li><li><p>安装好后，打开Tailsscale进行登录，可以选择Google与微软账号，这里我推荐使用微软账号，使用Google账号会使得IPad上面的Tailscale经常需要重新登录，而微软账号则不会。</p></li><li><p>在其他设备(电脑，ipad，手机)上安装Tailscale*(Ipad中的这个应用需要在美区的商店进行下载，只需要修改苹果账号的国家与地区就可以，不需要翻墙)*，并登录同一个账号。</p></li><li><p>同时登录了同一个账号的Tailscale的设备则会被认为处在 同一个局域网中，通过Tailscale提供的ip地址即可以访问群晖</p><img src="/posts/1dafad22/Tailscale%E7%99%BB%E9%99%86%E6%88%90%E5%8A%9F.png" class="" title="image-20230407160000641"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> 群晖 </tag>
            
            <tag> 校园网 </tag>
            
            <tag> Tailscale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中的Ubuntu无法正常使用systemctl操作</title>
      <link href="/posts/dbaf53d0.html"/>
      <url>/posts/dbaf53d0.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="/posts/dbaf53d0/docker.png" class="" title="image-20230403183630354"><p>​在docker中安装Ubuntu，试图用systemctl命令来实现Ubuntu开机后自动打开ssh，发现无法实现想要的效果。</p><img src="/posts/dbaf53d0/%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C.png" class="" title="image-20230403183804899"><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>​Loaded显示enabled说明ssh开机应该会自动启动，但是实际上开机之后却是inactive（没有成功运行）</p><p>​经过查阅资料，发现<strong>Docker只是提供了进程隔离，不是操作系统的虚拟</strong>，它并不是我想象中的虚拟机，不会模拟硬件，只是会为每一个应用提供隔离的运行环境。</p><p>​<strong>正常</strong>的Ubuntu系统的1号进程(PID&#x3D;1)是init，可以系统的初始化脚本，创建一系列的子进程，如图</p><img src="/posts/dbaf53d0/%E6%AD%A3%E5%B8%B8Ubuntu%E8%BF%9B%E7%A8%8B.png" class="" title="image-20230403185105035"><p>​<strong>Docker</strong>版本的Ubuntu的1号进程不是init，导致systemctl功能异常。</p><img src="/posts/dbaf53d0/Docker-Ubuntu%E8%BF%9B%E7%A8%8B.png" class="" title="image-20230403185230617"><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid --name ubuntu01 --privileged=true ubuntu /sbin/init</span><br><span class="line">docker exec -it ubuntu01 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><h4 id="docker-run-tid-name-ubuntu01-privileged-true-ubuntu-sbin-init"><a href="#docker-run-tid-name-ubuntu01-privileged-true-ubuntu-sbin-init" class="headerlink" title="docker run -tid --name ubuntu01 --privileged=true ubuntu /sbin/init"></a><code>docker run -tid --name ubuntu01 --privileged=true ubuntu /sbin/init</code></h4><p>​ubuntu01是容器(container)名称， ubuntu是映像(images)名称</p><p>​帮助中显示run的作用原文为:<code>run         Run a command in a new container</code></p><p>​所以这条指令的<strong>含义</strong>是利用ubuntu映像<strong>创建并运行</strong>一个名为ubuntu01的容器，–privileged&#x3D;true给予容器更高的特权，启动&#x2F;sbin&#x2F;init进程*(使系统初始化)*</p><p>​注意<strong>不同系统（Centos，Ubuntu）的init位置不同，Centos在&#x2F;usr&#x2F;sbin&#x2F;init，Ubuntu在&#x2F;sbin&#x2F;init</strong></p><h4 id="docker-exec-it-ubuntu01-bin-bash"><a href="#docker-exec-it-ubuntu01-bin-bash" class="headerlink" title="docker exec -it ubuntu01 /bin/bash"></a><code>docker exec -it ubuntu01 /bin/bash</code></h4><p>​帮助中显示exec的作用原文为:<code>exec        Run a command in a running container</code></p><p>​-it 与容器中的shell进行交流</p><p>​所以这条指令的<strong>含义</strong>是在已经启动的容器中运行<code>/bin/bash</code>指令<em>（启动一个bash shell）</em></p><h3 id="代码正确运行结果"><a href="#代码正确运行结果" class="headerlink" title="代码正确运行结果"></a>代码正确运行结果</h3><img src="/posts/dbaf53d0/%E4%BB%A3%E7%A0%81%E6%AD%A3%E7%A1%AE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" class="" title="image-20230403201120444"><h3 id="假如Ubuntu的-x2F-sbin-x2F-init文件不存在"><a href="#假如Ubuntu的-x2F-sbin-x2F-init文件不存在" class="headerlink" title="假如Ubuntu的&#x2F;sbin&#x2F;init文件不存在"></a>假如Ubuntu的&#x2F;sbin&#x2F;init文件不存在</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>​在使用<code>docker run -tid --name ubuntu01 --privileged=true ubuntu /sbin/init</code>代码进行操作后出现<strong>错误</strong>：</p><p><code>docker: Error response from daemon: OCI runtime create failed: container_linux.go:367: starting container process caused: exec: &quot;/sbin/init&quot;: stat /sbin/init: no such file or directory: unknown.</code></p><h4 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h4><p>​这说明我们使用的Ubuntu映像没有init文件，需要我们自行添加</p><p>​<img src="/posts/dbaf53d0/%E7%BC%BA%E5%B0%91init.png" class="" title="image-20230404220859176"></p><h4 id="解决办法一：修改容器的启动配置"><a href="#解决办法一：修改容器的启动配置" class="headerlink" title="解决办法一：修改容器的启动配置"></a>解决办法一：修改容器的启动配置</h4><p>​进入一个正常的Ubuntu系统，<code>cd /sbin</code>然后<code>ls -l|grep init</code>查看init文件，显示结果如下</p>   <img src="/posts/dbaf53d0/%E6%AD%A3%E5%B8%B8%E7%9A%84init%E6%98%AF%E4%BB%80%E4%B9%88.png" class="" title="image-20230404221059062"><p>​运行结果显示init文件实际上是systemd文件的<strong>软链接</strong>形式</p><p>   <em>lrwxrwxrwx中第一个字母l代表该文件是一个软链接</em></p><ol><li><p>利用<strong>映像</strong>创建一个容器，并进入终端（或者直接进入旧容器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid --name ubuntu01  ubuntu</span><br><span class="line">docker exec -it ubuntu01 /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>使用<code>apt update&amp;&amp;apt upgrade</code>更新软件源</p></li><li><p>使用<code>apt install systemd</code>下载一个systemd到Linux系统</p></li><li><p>在&#x2F;sbin目录里建立一个名为init的软链接指向systemd,使用指令<code>ln -s /lib/systemd/systemd /sbin/init</code></p></li><li><p>退出容器的bash shell，使用<code>docker info</code>查看docker容器的存储位置，<em>例如：<code>Docker Root Dir: /volume1/@docker</code></em></p></li><li><p>进入docker 目录下的containers&#x2F;目录，找到跟容器id(<code>docker ps -a可以列出所有的容器相关信息</code>)相同的目录（或者可以使用<code>docker inspect &quot;容器名&quot;</code>查看和容器有关的信息）</p></li><li><p>ls 查看文件构造</p><img src="/posts/dbaf53d0/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" class="" title="image-20230404224428235"><p>config.v2.json即为配置文件</p></li><li><p><code>cp config.v2.json config.v2.json.origin</code>备份配置文件</p></li><li><p><code>vim config.v2.json</code>修改配置文件,将Path修改为”&#x2F;sbin&#x2F;init”,Cmd修改为”&#x2F;sbin&#x2F;init”，<strong>重点：”NoNewPrivileges”改为true，否则修改后的配置文件在启动容器后又会变回原样</strong><br>  <em>Path填写可执行程序,Args填写可执行程序的参数,Cmd完整的命令</em></p></li><li><p>输入<code>service docker restart</code>指令来重启docker<strong>注意是重启docker，而不是重启container</strong><br> 如果是群晖系统则需要使用</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash /var/packages/Docker/scripts/start-stop-status stop;</span><br><span class="line">bash /var/packages/Docker/scripts/start-stop-status start;</span><br></pre></td></tr></table></figure></li></ol><p>11.输入<code>docker start ubuntu01</code>来启动容器，输入<code>ps aux</code>查看进程，发现Ubuntu第一个进程为init，大功告成</p><img src="/posts/dbaf53d0/%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png" class="" title="image-20230405135253531"><h4 id="解决办法二：修改容器后，利用容器commit映像出来，再使用映像建立一个容器"><a href="#解决办法二：修改容器后，利用容器commit映像出来，再使用映像建立一个容器" class="headerlink" title="解决办法二：修改容器后，利用容器commit映像出来，再使用映像建立一个容器"></a>解决办法二：修改容器后，利用容器commit映像出来，再使用映像建立一个容器</h4><p><em>前四步都与解决方法一一致</em></p><ol><li><p>利用<strong>映像</strong>创建一个容器，并进入终端（或者直接进入旧容器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid --name ubuntu01  ubuntu</span><br><span class="line">docker exec -it ubuntu01 /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>使用<code>apt update&amp;&amp;apt upgrade</code>更新软件源</p></li><li><p>使用<code>apt install systemd</code>下载一个systemd到Linux系统</p></li><li><p>在&#x2F;sbin目录里建立一个名为init的软链接指向systemd,使用指令<code>ln -s /lib/systemd/systemd /sbin/init</code></p></li><li><p>退出容器，使用<code>docker commit ubuntu01 test</code>将修改好的容器ubuntu01 commit为test映像</p></li><li><p>这下利用test映像即可以使用代码而不报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid --name ubuntu02 --privileged=true test /sbin/init</span><br><span class="line">docker exec -it ubuntu02 /bin/bash</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> BUG大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> NAS </tag>
            
            <tag> Docker </tag>
            
            <tag> 群晖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Vmware虚拟机无法ping通开发板</title>
      <link href="/posts/76f723b3.html"/>
      <url>/posts/76f723b3.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题详细描述"><a href="#问题详细描述" class="headerlink" title="问题详细描述"></a>问题详细描述</h2><p>​嵌入式课程中，本人使用Vmware虚拟机运行Ubuntu22.04操作系统，无法与开发版ping通，导致后续实验无法进行。本人的使用的轻薄本没有直接的网线接口，使用的usb转接口连接网线。</p><img src="/posts/76f723b3/USB%E8%BD%AC%E6%8E%A5%E5%8F%A3.jpg" class="" title="9bcddc0a6497ba4c8a9889f6a3c1e9e"><h2 id="一、确保win10电脑与VMware有关的服务处于开启状态"><a href="#一、确保win10电脑与VMware有关的服务处于开启状态" class="headerlink" title="一、确保win10电脑与VMware有关的服务处于开启状态"></a>一、确保win10电脑与VMware有关的服务处于开启状态</h2><p>​在win10系统中使用【win+r】快捷键，输入services.msc，进入管理win10服务的平台</p><img src="/posts/76f723b3/win+r.png" class="" title="image-20230313183818115"><p>​在列表中找到以VMware为开头的服务，查看状态，如果处于关闭状态则将其启动。</p><img src="/posts/76f723b3/%E6%9C%8D%E5%8A%A1.png" class="" title="image-20230313184009878"><h2 id="二、插入网线，将WLAN与网线共享网络，使电脑可以识别网线为网卡"><a href="#二、插入网线，将WLAN与网线共享网络，使电脑可以识别网线为网卡" class="headerlink" title="二、插入网线，将WLAN与网线共享网络，使电脑可以识别网线为网卡"></a>二、插入网线，将WLAN与网线共享网络，使电脑可以识别网线为网卡</h2><blockquote><p>一般外设接入电脑后，如果Vmware虚拟机处于开启状态，会弹出窗口询问接入主机还是接入虚拟机，插入网线后，我们选择接入主机而不是虚拟机，（连接开发板的数据线需要接入虚拟机）</p></blockquote><p>找到win10状态栏中的网络图标（平常连接WiFi的地方），鼠标右键选择<em>打开”网络和Internet”设置</em>，在高级网络设置中，选择更改设配器选项，</p><img src="/posts/76f723b3/%E6%9B%B4%E6%94%B9%E8%AE%BE%E9%85%8D%E5%99%A8%E9%80%89%E9%A1%B9.png" class="" title="image-20230313184707143"><p>进入到网络连接界面，本人的笔记本使用WLAN连接WiFi，以太网3（）是开发板与笔记本连接的网线<em>（如果不确定是哪个，可以反复插拔观察确认）</em>，所以我们需要将<em>WLAN与以太网3</em>进行网络共享。</p><img src="/posts/76f723b3/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5.png" class="" title="image-20230313185750049"><p>鼠标右键WLAN，选择属性，共享，勾选*允许其他网络用户通过此计算机的 Internet 连接来连接(N)*，在下拉选项中选择以太网3（根据自己的电脑情况进行灵活变更），点击确定。</p><img src="/posts/76f723b3/WLAN%E5%B1%9E%E6%80%A7.png" class="" title="image-20230313185314154"><p>确定之后，可以看见<em>网络连接界面以太网3</em>下面如同WLAN一样，多出了一行字母，倘若看不见，就切换查看模式为平铺，本人的电脑显示为<strong>Realtek USB GbE Family Controller</strong>，我们后面需要用到这串字符。</p><h2 id="三、修改Vmware的网络设置"><a href="#三、修改Vmware的网络设置" class="headerlink" title="三、修改Vmware的网络设置"></a>三、修改Vmware的网络设置</h2><h3 id="修改网络适配器选项"><a href="#修改网络适配器选项" class="headerlink" title="修改网络适配器选项"></a>修改网络适配器选项</h3><p>打开Ubuntu后在Vmware上方的菜单栏中选择虚拟机（M），设置，硬件，在列表中选择网络适配器，自定义选择<strong>VMnet0</strong>，选择确定</p><img src="/posts/76f723b3/%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D%E5%99%A8%E9%80%89%E9%A1%B9.png" class="" title="image-20230313191353577"><h3 id="修改虚拟网络编辑器"><a href="#修改虚拟网络编辑器" class="headerlink" title="修改虚拟网络编辑器"></a>修改虚拟网络编辑器</h3><p>在Vmware菜单栏中，选择编辑，虚拟网络编辑器，点击更改设置</p><img src="/posts/76f723b3/%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E8%BE%91%E5%99%A8.png" class="" title="image-20230313191517621"><p>授予管理员权限后，会多出来VMnet0，选择模式为桥接模式，并与网线网卡，即上文的<strong>Realtek USB GbE Family Controller</strong>（不同人可能是不同的名）相桥接，确定。</p><h2 id="四、开发板与虚拟机互ping"><a href="#四、开发板与虚拟机互ping" class="headerlink" title="四、开发板与虚拟机互ping"></a>四、开发板与虚拟机互ping</h2><h3 id="修改开发板与虚拟机的ip地址为同一网段，相互ping-ip地址"><a href="#修改开发板与虚拟机的ip地址为同一网段，相互ping-ip地址" class="headerlink" title="修改开发板与虚拟机的ip地址为同一网段，相互ping ip地址"></a>修改开发板与虚拟机的ip地址为同一网段，相互ping ip地址</h3><p><code>**ifconfig**</code>为Linux系统查看ip地址的指令</p><p><code>**ifconfig+网卡名（eth0）+ip地址**</code>为修改系统ip地址的指令</p><p>将开发板与虚拟机的ip地址修改到同一网段，例如（192.168.137.10与192.168.137.20）</p><p><code>ping+ip地址</code>，检测当前机器能否与目标ip相连通</p><h3 id="成功ping通，但是返回-DUP-（没有出现该状况请忽略）"><a href="#成功ping通，但是返回-DUP-（没有出现该状况请忽略）" class="headerlink" title="成功ping通，但是返回(DUP!)     （没有出现该状况请忽略）"></a>成功ping通，但是返回(DUP!)     <em>（没有出现该状况请忽略）</em></h3><img src="/posts/76f723b3/%E8%BF%94%E5%9B%9Edup%EF%BC%81.jpg" class="" title="img"><p>重新打开服务控制平台（win+r 输入services.msc），找到Routing and Remote Access服务，将其关闭（<strong>本人原本这服务处于禁止运行状态，但我将其启动并再次关闭后互ping也变正常</strong>），重新互ping，不再返回错误信息。</p><img src="/posts/76f723b3/ping%E9%80%9A.jpg" class="" title="img"><h2 id="其他错误"><a href="#其他错误" class="headerlink" title="其他错误"></a>其他错误</h2><h3 id="检测不到开发板的USB串口"><a href="#检测不到开发板的USB串口" class="headerlink" title="检测不到开发板的USB串口"></a>检测不到开发板的USB串口</h3><p>确保虚拟机的USB设置如下图所示</p><img src="/posts/76f723b3/USB%E8%AE%BE%E7%BD%AE.png" class="" title="image-20230313193040437">]]></content>
      
      
      <categories>
          
          <category> BUG大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 嵌入式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04 NFS服务挂载到开发板的时遇到的BUG</title>
      <link href="/posts/6416c38f.html"/>
      <url>/posts/6416c38f.html</url>
      
        <content type="html"><![CDATA[<h2 id="错误一：即使关闭了防火墙，连接依旧超时"><a href="#错误一：即使关闭了防火墙，连接依旧超时" class="headerlink" title="错误一：即使关闭了防火墙，连接依旧超时"></a>错误一：即使关闭了防火墙，连接依旧超时</h2><p><strong>错误描述：</strong>在Ubuntu设置好NFS服务后进行挂载，发现<strong>即使关闭了防火墙，也不起作用</strong></p><p>显示：<img src="/posts/6416c38f/%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6.png" class="" title="微信图片_20230310135006"></p><p><strong>错误来源</strong>：开发板安装的NFS服务版本过低，Ubuntu22.04下载的NFS版本高，默认情况下不支持较低版本NFS挂载服务，需要我们手动对配置进行修改。</p><p><strong>解决方法：</strong></p><p>​1.输入代码<code>cat /proc/fs/nfsd/versions</code>查看当前NFS服务所支持的版本，输出结果如果为</p><img src="/posts/6416c38f/nfs%E6%94%AF%E6%8C%81%E7%89%88%E6%9C%AC.png" class="" title="微信图片_20230310135112"><p><em>可以看见其他数字前面都是+号，唯独2前面是-号，说明此时NFS服务不支持NFS2版本进行挂载服务，从而出现了连接超时。</em></p><p>​2.修改虚拟机的nfs配置，<code>vim /etc/default/nfs-kernel-server</code>，修改三个参数为</p><p>​<code>RPCNFSDCOUNT=&quot;-V 2 8&quot;</code>;<code>RPCMOUNTDOPTS=&quot;-V 2 --manage-gids&quot;</code>;<code>RPCSVCGSSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot;;</code></p><p>​    3.输入<code>RPCSVCGSSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot;</code>,修改两个参数</p><p>​<code>udp=y</code>;<code>vers2=y</code></p><p>​4.重启nfs服务（<code>sudo /etc/init.d/portmap restart</code>;<code>sudo /etc/init.d/**nfs**-kernel-server restart</code>），再查看现在支持的nfs版本（<code>cat /proc/fs/nfsd/versions</code>）。</p><img src="/posts/6416c38f/%E9%87%8D%E5%90%AFnfs%E7%9A%84%E7%BB%93%E6%9E%9C.png" class="" title="微信图片_20230310140318"><p><em>可以看见目前已经支持了nfs2，可以正常进行挂载服务</em></p><p><em>此方法学习自<a href="https://blog.csdn.net/weixin_56646002/article/details/127388021?spm=1001.2014.3001.5506">门牙会稍息</a></em></p><h2 id="错误二：成功挂载后，双方文件夹不互相同步"><a href="#错误二：成功挂载后，双方文件夹不互相同步" class="headerlink" title="错误二：成功挂载后，双方文件夹不互相同步"></a>错误二：成功挂载后，双方文件夹不互相同步</h2><p><strong>错误来源：</strong>假设Ubuntu为A,开发板为B，我们想将<code>A:/home/nfs </code>挂载至<code>B:/mnt</code>文件夹，挂载时A正处于<code>/home/nfs</code>B正处于<code>B:/mnt</code>路径下，问题原因我尚未理解。</p><p><strong>解决办法：</strong>先解决开发板的挂载状态，再返回根目录后进行挂载</p><h2 id="错误三：安装交叉编译环境时，配置好环境后输入arm-linux-gcc-v提示command-not-founnd"><a href="#错误三：安装交叉编译环境时，配置好环境后输入arm-linux-gcc-v提示command-not-founnd" class="headerlink" title="错误三：安装交叉编译环境时，配置好环境后输入arm-linux-gcc -v提示command not founnd"></a>错误三：安装交叉编译环境时，配置好环境后输入<code>arm-linux-gcc -v</code>提示<code>command not founnd</code></h2><p><strong>错误原因：</strong>有可能安装了32位版本的编译器，而我们的Ubuntu是64位的</p><p><strong>解决办法：</strong>安装32位依赖包，输入<code>apt install lib32z1</code>，再输入<code>arm-linux-gcc -v</code>查看编译器版本</p><img src="/posts/6416c38f/%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%AF%91%E5%99%A8%E7%89%88%E6%9C%AC.png" class="" title="image-20230310142124403"><p><em>gcc可以正常使用</em></p>]]></content>
      
      
      <categories>
          
          <category> BUG大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 嵌入式系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
