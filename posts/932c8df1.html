<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>MIT6.S081中Systemcall的调用流程 | 水更流的个人博客</title><meta name="author" content="水更流"><meta name="copyright" content="水更流"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="总结了MIT6.S081中Systemcall调用的流程"><meta property="og:type" content="article"><meta property="og:title" content="MIT6.S081中Systemcall的调用流程"><meta property="og:url" content="https://www.shui2000.top/posts/932c8df1.html"><meta property="og:site_name" content="水更流的个人博客"><meta property="og:description" content="总结了MIT6.S081中Systemcall调用的流程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.shui2000.top/img/wallpaper-106.png"><meta property="article:published_time" content="2024-04-22T10:58:30.000Z"><meta property="article:modified_time" content="2025-04-29T05:14:03.704Z"><meta property="article:author" content="水更流"><meta property="article:tag" content="MIT6.S081"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="Systemcall"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.shui2000.top/img/wallpaper-106.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.shui2000.top/posts/932c8df1.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="cJ0XSy1gV6L4I4FF1EFryH691Jo_E10-imUvQCAlz5Y"><meta name="baidu-site-verification" content="codeva-BZtFxKJeHT"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"距离上次文章更新已经过了",messageNext:"天，本篇文章可能已经不再实用。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:230},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 水更流",link:"链接: ",source:"来源: 水更流的个人博客",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"top-left"},source:{justifiedGallery:{js:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js",css:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!0,percent:{toc:!0,rightside:!1}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MIT6.S081中Systemcall的调用流程",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-04-29 13:14:03"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const n=saveToLocal.get("aside-status");void 0!==n&&("hide"===n?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="https://pic.shui2000.top/source/css/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="/css/emoji.css"><link rel="stylesheet" href="https://pic.shui2000.top/source/css/index.css"><div id="myscoll"></div><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248 626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><link rel="stylesheet" href="https://pic.shui2000.top/source/css/clock.min.css"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://pic.shui2000.top/source/css/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://pic.shui2000.top/source/css/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://pic.shui2000.top/source/css/tag-font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://pic.shui2000.top/source/css/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://pic.shui2000.top/source/js/carousel-touch.js"></script><link rel="stylesheet" href="https://pic.shui2000.top/source/css/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar1.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye"></i><svg class="icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-zhuye"></use></svg> <span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shalou"></i><svg class="icon fas fa-archive" aria-hidden="true"><use xlink:href="#icon-shalou"></use></svg> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon fas fa-folder-open" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg> <span>分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-biaoqian"></i><svg class="icon fas fa-tags" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg> <span>标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-jilu"></i><svg class="icon fas fa-folder-open" aria-hidden="true"><use xlink:href="#icon-jilu"></use></svg> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon fas fa-link" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg> <span>友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://pic.shui2000.top/img/wallpaper-106.png')"><nav id="nav"><span id="blog-info"><a href="/" title="水更流的个人博客"><span class="site-name">水更流的个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye"></i><svg class="icon fas fa-home" aria-hidden="true"><use xlink:href="#icon-zhuye"></use></svg> <span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shalou"></i><svg class="icon fas fa-archive" aria-hidden="true"><use xlink:href="#icon-shalou"></use></svg> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon fas fa-folder-open" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg> <span>分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-biaoqian"></i><svg class="icon fas fa-tags" aria-hidden="true"><use xlink:href="#icon-biaoqian"></use></svg> <span>标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-jilu"></i><svg class="icon fas fa-folder-open" aria-hidden="true"><use xlink:href="#icon-jilu"></use></svg> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon fas fa-link" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg> <span>友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MIT6.S081中Systemcall的调用流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-22T10:58:30.000Z" title="发表于 2024-04-22 18:58:30">2024-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-29T05:14:03.704Z" title="更新于 2025-04-29 13:14:03">2025-04-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MIT6.S081中Systemcall的调用流程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MIT6.S081 项目中的许多实验都涉及到了系统调用（System Call）的使用，我在实验过程中往往依葫芦画瓢在原有的System Call基础上使用，没有真正理解System Call的流程，本篇笔记打算<strong>以<code>sys_sleep</code>为例子</strong>梳理一下Xv6系统中 System Call的调用流程。</p><h2 id="一、用户态（-x2F-user-x2F-）中的系统调用"><a href="#一、用户态（-x2F-user-x2F-）中的系统调用" class="headerlink" title="一、用户态（&#x2F;user&#x2F;）中的系统调用"></a>一、用户态（&#x2F;user&#x2F;）中的系统调用</h2><p>我们可以在<code>/user/user.h</code>中找到sleep函数的函数声明，却<strong>无法找到sleep函数的函数定义</strong>。</p><p>实际上我们可以在<code>user/usys.pl</code>中找到<strong>除了函数调用以外sleep函数的出现</strong>,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">#!/usr/bin/perl -w</span><br><span class="line"></span><br><span class="line"># Generate usys.S, the stubs <span class="keyword">for</span> syscalls.</span><br><span class="line"></span><br><span class="line">print <span class="string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">print <span class="string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">....</span><br><span class="line"><span class="comment">//剩余代码都是entry(&quot;system call&quot;)的格式，故省略</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 代码含义解释来自于chatgpt3.5</span></span><br><span class="line"><span class="comment">这段代码是用 Perl 编写的脚本，用于生成 `usys.S` 文件，其中包含系统调用的存根（stubs）。我来解释一下代码的含义：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. `#!/usr/bin/perl -w`：这是脚本的 shebang 行，指示系统使用 Perl 解释器执行该脚本。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. `print &quot;# generated by usys.pl - do not edit\n&quot;;`：打印一条注释，说明该文件是由 `usys.pl` 生成的，不应手动编辑。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. `print &quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;;`：打印 `#include` 指令，将 `kernel/syscall.h` 文件包含进来，该文件可能包含了系统调用的相关定义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. `sub entry &#123; ... &#125;`：定义了一个名为 `entry` 的子例程，用于生成系统调用的存根。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 在 `entry` 子例程中，对于每个传入的系统调用名，都生成了相应的存根。这些存根包括以下几个步骤：</span></span><br><span class="line"><span class="comment">   - `.global $name`：将该系统调用名声明为全局符号。</span></span><br><span class="line"><span class="comment">   - `$&#123;name&#125;:`：定义一个标签，表示系统调用的起始点。</span></span><br><span class="line"><span class="comment">   - `li a7, SYS_$&#123;name&#125;`：将系统调用号加载到寄存器 a7 中。这里假设 `SYS_$&#123;name&#125;` 是一个宏，用于获取该系统调用的编号。</span></span><br><span class="line"><span class="comment">   - `ecall`：触发系统调用。</span></span><br><span class="line"><span class="comment">   - `ret`：返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. 最后，对于每个系统调用，都调用了 `entry` 子例程，传入相应的系统调用名，以生成相应的存根。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">总体来说，这段代码的作用是生成一系列系统调用的存根，这些存根可以用于在特定的环境中进行系统调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、生成的usys-S文件中的汇编语言"><a href="#二、生成的usys-S文件中的汇编语言" class="headerlink" title="二、生成的usys.S文件中的汇编语言"></a>二、生成的usys.S文件中的汇编语言</h2><p>通过<code>user/usys.pl</code>的代码我们可以推测其为每一个系统调用（System Call）都进行了entry操作，生成到了<code>user/usys.S</code>文件中,该文件<strong>每个系统调用都对应三行汇编语言</strong>，我只复制了与sleep相关的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># generated by usys.pl - do not edit</span><br><span class="line">#include &quot;kernel/syscall.h&quot;</span><br><span class="line">.global sleep</span><br><span class="line">sleep:</span><br><span class="line"> li a7, SYS_sleep</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p><code>#include &quot;kernel/syscall.h&quot;</code>代表汇编文件前插入了<code>kernel/syscall.h</code>，我们在遇到不懂的内容时，应该去该文件查看寻找问题的答案。</p><h3 id="1-li-a7-SYS-sleep"><a href="#1-li-a7-SYS-sleep" class="headerlink" title="1.li a7, SYS_sleep"></a>1.li a7, SYS_sleep</h3><p>这行代码的含义是将系统调用号 <code>SYS_sleep</code> 加载到寄存器 <code>a7</code> 中。<strong>在 RISC-V 架构中，寄存器 <code>a7</code> 通常被用作系统调用号的参数寄存器。</strong>因此，这行代码的目的是将 <code>SYS_sleep</code> 这个系统调用的编号加载到 <code>a7</code> 寄存器，以便在调用系统调用时使用。</p><p><code>SYS_sleep</code>的值可以在<code>kernel/syscall.h</code>中找到,为13。该文件给每一个system call都对应了一个数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#define SYS_sbrk   12</span><br><span class="line">#define SYS_sleep  13</span><br><span class="line">#define SYS_uptime 14</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-ecall（该指令为CPU指令）"><a href="#2-ecall（该指令为CPU指令）" class="headerlink" title="2.ecall（该指令为CPU指令）"></a>2.ecall（该指令为CPU指令）</h3><p>在<a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec06-isolation-and-system-call-entry-exit-robert">Lec06 Isolation &amp; system call entry&#x2F;exit (Robert)</a>课程中我们可以学习到ecall指令的作用（ecall内容的笔记基本摘抄自课程翻译，不理解可以去看原课程）：</p><h4 id="2-1-ecall将代码从user-mode改到supervisor-mode"><a href="#2-1-ecall将代码从user-mode改到supervisor-mode" class="headerlink" title="2.1 ecall将代码从user mode改到supervisor mode"></a>2.1 <code>ecall</code>将代码从<code>user mode</code>改到<code>supervisor mode</code></h4><p>注意:作为代码编写者的我们并<strong>没有办法能直接分辨</strong>系统处于user mode还是supervisor mode，下图为PTE结构，Flag中存在标志位U，xv6系统标志位U为1的时候，只有user mode下能访问而supervisor mode不能访问，我们通过这个方法来间接分辨系统处于什么状态。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/932c8df1/PTE%E7%BB%93%E6%9E%84.png" title="image-20240421180742156"><h4 id="2-2-ecall将程序计数器的值保存在了SEPC寄存器"><a href="#2-2-ecall将程序计数器的值保存在了SEPC寄存器" class="headerlink" title="2.2 ecall将程序计数器的值保存在了SEPC寄存器"></a>2.2 <code>ecall</code>将程序计数器的值保存在了<code>SEPC</code>寄存器</h4><p>SEPC寄存器保存的值将在 <code>supervisor mode</code> 返回至 <code>user mode</code>时发挥作用</p><h4 id="2-3-ecall会跳转到STVEC寄存器指向的指令（uservec函数）"><a href="#2-3-ecall会跳转到STVEC寄存器指向的指令（uservec函数）" class="headerlink" title="2.3 ecall会跳转到STVEC寄存器指向的指令（uservec函数）"></a>2.3 <code>ecall</code>会跳转到<code>STVEC</code>寄存器指向的指令（uservec函数）</h4><p>所以现在，ecall帮我们做了一点点工作，但是实际上我们离执行内核中的C代码还差的很远。接下来：</p><ul><li>我们需要保存32个用户寄存器的内容，这样当我们想要恢复用户代码执行时，我们才能恢复这些寄存器的内容。</li><li><strong>因为现在我们还在user page table，我们需要切换到kernel page table。</strong></li><li>我们需要创建或者找到一个kernel stack，并将Stack Pointer寄存器的内容指向那个kernel stack。这样才能给C代码提供栈。</li><li>我们还需要跳转到内核中C代码的某些合理的位置。</li></ul><p><strong>ecall并不会为我们做这里的任何一件事（以上四点的详细实现过程在三、uservec上）。</strong></p><h5 id="2-3-1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）"><a href="#2-3-1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）" class="headerlink" title="2.3.1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）"></a>2.3.1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）</h5><p>当然，我们可以通过修改硬件让ecall为我们完成这些工作，而不是交给软件来完成。并且，我们也将会看到，在软件中完成这些工作并不是特别简单。所以你现在就会问，为什么ecall不多做点工作来将代码执行从用户空间切换到内核空间呢？为什么ecall不会保存用户寄存器，或者切换page table指针来指向kernel page table，或者自动的设置Stack Pointer指向kernel stack，或者直接跳转到kernel的C代码，而不是在这里运行复杂的汇编代码？</p><p>实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是RISC-V并不会，RISC-V秉持了这样一个观点：ecall只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管XV6并没有使用这里提供的灵活性，但是一些其他的操作系统用到了。</p><ul><li>举个例子，因为这里的ecall是如此的简单，或许某些操作系统可以在不切换page table的前提下，执行部分系统调用。切换page table的代价比较高，如果ecall打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换page table。</li><li>某些操作系统同时将user和kernel的虚拟地址映射到一个page table中，这样在user和kernel之间切换时根本就不用切换page table。对于这样的操作系统来说，如果ecall切换了page table那将会是一种浪费，并且也减慢了程序的运行。</li><li>或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于于软件，编程语言，和编译器。通过不保存所有的32个寄存器或许可以节省大量的程序运行时间，所以你不会想要ecall迫使你保存所有的寄存器。</li><li>最后，对于某些简单的系统调用或许根本就不需要任何stack，所以对于一些非常关注性能的操作系统，ecall不会自动为你完成stack切换是极好的。</li></ul><p>所以，<strong>ecall尽量的简单可以提升软件设计的灵活性</strong>。</p><h5 id="2-3-2-为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）"><a href="#2-3-2-为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）" class="headerlink" title="2.3.2 为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）"></a>2.3.2 为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）</h5><p>ecall只会更新CPU中的mode标志位为supervisor，并且设置程序计数器成STVEC寄存器内的值。在进入到用户空间之前，内核会将trampoline page的地址存在STVEC寄存器中。所以ecall的下一条指令的位置是STVEC指向的地址，也就是trampoline page的起始地址。（注，实际上ecall是CPU的指令，自然在gdb中看不到具体内容）</p><h3 id="3-ret"><a href="#3-ret" class="headerlink" title="3.ret"></a>3.ret</h3><p>返回到用户态程序原本的运行位置，PC值从<code>SEPC</code>寄存器中读取</p><h2 id="三、trampoline-page"><a href="#三、trampoline-page" class="headerlink" title="三、trampoline page"></a>三、trampoline page</h2><p>在ecall函数执行完后，程序pc值指向了uservec函数，该函数位于trampoline page的起始，<strong>仍处于 user page table中（意味着页表没有发生切换，该页表上没有处理system call 的内核代码，需要我们切换到kernel page table上）</strong></p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/932c8df1/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" title="image-20240421182525160"><h3 id="1-trampoline-映射时的特别之处"><a href="#1-trampoline-映射时的特别之处" class="headerlink" title="1.trampoline 映射时的特别之处"></a>1.trampoline 映射时的特别之处</h3><p>在<code>kernel page table</code>中，trampoline使用直接映射，映射虚拟地址最高处为trampoline</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// map the trampoline page to the highest address,</span><br><span class="line">// in both user and kernel space.</span><br><span class="line">#define TRAMPOLINE (MAXVA - PGSIZE)</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kvminit()</span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = (pagetable_t) kalloc();</span><br><span class="line">  memset(kernel_pagetable, 0, PGSIZE);</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  // map the trampoline for trap entry/exit to</span><br><span class="line">  // the highest virtual address in the kernel.</span><br><span class="line">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在为进程分配<code>user page table</code>时,虚拟地址的最高处同样映射为Trampoline，同时<strong>PTE_U为复位（0）</strong>，表明只有supervisor可以使用它，并且映射trampoline时使用的物理地址与<code>kernel page table</code>使用的物理地址一致，这意味着：**<code>kernel page table</code>与<code>user page table</code>的虚拟地址的最高处映射了同一个Trampoline**。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-Uservec函数"><a href="#2-Uservec函数" class="headerlink" title="2.Uservec函数"></a>2.Uservec函数</h3><p><code>uservec</code> 为汇编代码，代码可以在<code>kernel/trampoline.S</code>中查看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">	# swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><h4 id="2-1-csrrw-a0-sscratch-a0"><a href="#2-1-csrrw-a0-sscratch-a0" class="headerlink" title="2.1 csrrw a0, sscratch, a0"></a>2.1 csrrw a0, sscratch, a0</h4><p>在进入到user space之前，内核会将trapframe page的地址保存在<strong>SSCRATCH寄存器</strong>中，也就是0x3fffffe000这个地址。</p><p><strong>csrrw指令</strong>，交换了a0与sscratch寄存器的值，现在a0寄存器中存储的是<strong>trapframe page的地址</strong>，其在<code>user page table</code></p><p>中被映射到了Trampoline的下方。</p><h5 id="问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？"><a href="#问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？" class="headerlink" title="问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？"></a>问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？</h5><p>在内核<strong>前一次切换回用户空间时</strong>，内核会执行set sscratch指令，将这个寄存器的内容设置为0x3fffffe000，也就是trapframe page的虚拟地址。所以，当我们在运行用户代码，比如运行Shell时，SSCRATCH保存的就是指向trapframe的地址。之后，Shell执行了ecall指令，跳转到了trampoline page，这个page中的第一条指令会交换a0和SSCRATCH寄存器的内容。所以，SSCRATCH中的值，也就是指向trapframe的指针现在存储与a0寄存器中</p><h6 id="深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？"><a href="#深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？" class="headerlink" title="深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？"></a>深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？</h6><p>这个寄存器存在于CPU上，这是CPU上的一个特殊寄存器。内核在什么时候设置的它呢？这有点复杂。它被设置的实际位置，我们可以看下<code>kernel/trampoline.S</code>末尾的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// kernel/trampoline.S</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line"># return to user mode and user pc.</span><br><span class="line"># usertrapret() set up sstatus and sepc.</span><br><span class="line">sret</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码是<strong>内核在返回到用户空间之前执行的最后两条指令</strong>。在内核返回到用户空间时，会恢复所有的用户寄存器。之后会再次执行交换指令，csrrw。**因为之前内核已经设置了a0保存的是trapframe地址(注意：从uservec到trampoline代码结尾过程中执行了诸如usertrap、usertrapret等代码，那么a0寄存器一定不是之前<code>csrrw a0, sscratch, a0</code>代码修改后的a0值)**，经过交换之后SSCRATCH仍然指向了trapframe page地址，而a0也恢复成了之前的数值。</p><p>最后<code>sret</code>返回到了用户空间</p><h6 id="a0寄存器中的值是怎么来的？"><a href="#a0寄存器中的值是怎么来的？" class="headerlink" title="a0寄存器中的值是怎么来的？"></a>a0寄存器中的值是怎么来的？</h6><p>查看<code>kernel/trap.c</code>中<code>usertrapret</code>函数的最后两行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  // jump to trampoline.S at the top of memory, which </span><br><span class="line">  // switches to the user page table, restores user registers,</span><br><span class="line">  // and switches to user mode with sret.</span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是内核返回到用户空间的最后的C函数。C函数做的最后一件事情是调用fn函数，传递的参数是TRAMFRAME和user page table。<strong>在C代码中，当你调用函数，第一个参数会存在a0</strong>，这就是为什么a0里面的数值是指向trapframe的指针。</p><h6 id="当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）"><a href="#当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）" class="headerlink" title="当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）"></a>当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）</h6><p>好的，或许对于这个问题的一个答案是：<strong>一台机器总是从内核开始运行的</strong>，当机器启动的时候，它就是在内核中。 任何时候，不管是进程第一次启动还是从一个系统调用返回，进入到用户空间的唯一方法是就是执行sret指令。sret指令是由RISC-V定义的用来从supervisor mode转换到user mode。所以，在任何用户代码执行之前，内核会执行fn函数，并设置好所有的东西，例如SSCRATCH，STVEC寄存器。</p><h4 id="2-2-sd-ra-40-a0"><a href="#2-2-sd-ra-40-a0" class="headerlink" title="2.2 sd ra, 40(a0)"></a>2.2 sd ra, 40(a0)</h4><p>现在我们保存了a0中原有的值，并且得到了trapframe page的地址，user mode下其余寄存器中的值，可以<strong>通过sd指令保存到<code>user page table</code>中trapframe的不同偏移位置</strong></p><h5 id="问题-寄存器保存在了trapframe-page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe-page），而不是使用程序的栈"><a href="#问题-寄存器保存在了trapframe-page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe-page），而不是使用程序的栈" class="headerlink" title="问题 寄存器保存在了trapframe page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe page），而不是使用程序的栈?"></a>问题 寄存器保存在了trapframe page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe page），而不是使用程序的栈?</h5><p>这里或许有两个问题:</p><p>1.为什么我们要保存寄存器？为什么内核要保存寄存器的原因，是因为内核即将要运行会覆盖这些寄存器的C代码。如果我们想正确的恢复用户程序，我们需要将这些寄存器恢复成它们在ecall调用之前的数值，所以我们需要将所有的寄存器都保存在trapframe中，这样才能在之后恢复寄存器的值</p><p>2.为什么这些寄存器保存在trapframe，而不是用户代码的栈中？这个问题的答案是，我们不确定用户程序是否有栈，必然有一些编程语言没有栈，对于这些编程语言的程序，Stack Pointer不指向任何地址。当然，也有一些编程语言有栈，但是或许它的格式很奇怪，内核并不能理解。比如，编程语言以堆中以小块来分配栈，编程语言的运行时知道如何使用这些小块的内存来作为栈，但是内核并不知道。所以，如果我们想要运行任意编程语言实现的用户程序，内核就不能假设用户内存的哪部分可以访问，哪部分有效，哪部分存在。所以内核需要自己管理这些寄存器的保存，这就是为什么内核将这些内容保存在属于内核内存的trapframe中，而不是用户内存</p><h4 id="2-3-csrr-t0-sscratch-sd-t0-112-a0"><a href="#2-3-csrr-t0-sscratch-sd-t0-112-a0" class="headerlink" title="2.3   csrr t0, sscratch ;sd t0, 112(a0)"></a>2.3 csrr t0, sscratch ;sd t0, 112(a0)</h4><p>将<code>sscratch</code>中的值（实际上是a0寄存器中的原始值）保存在t0寄存器当中，将t0寄存器中的值保存在trapframe page偏移112字节的位置当中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//kernel/proc.h</span><br><span class="line">struct trapframe &#123;</span><br><span class="line"> ......</span><br><span class="line"> /* 112 */ uint64 a0;</span><br><span class="line"> .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据结构体定义，trapframe page 偏移112字节的位置是a0寄存器。</p><p>所以这两行代码的<strong>实际作用</strong>：将a0寄存器原本的值正确的保存在trapframe 当中</p><h4 id="2-4-ld-sp-8-a0"><a href="#2-4-ld-sp-8-a0" class="headerlink" title="2.4 ld sp, 8(a0)"></a>2.4 ld sp, 8(a0)</h4><p>该指令将a0偏移8个字节的数据加载到sp（stack pointer）寄存器当中，a0寄存器当中存储的是trapframe page的地址。通过查看trapframe page的结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//kernel/proc.h</span><br><span class="line">struct trapframe &#123;</span><br><span class="line">  /*   0 */ uint64 kernel_satp;   // kernel page table</span><br><span class="line">  /*   8 */ uint64 kernel_sp;     // top of process&#x27;s kernel stack</span><br><span class="line">  /*  16 */ uint64 kernel_trap;   // usertrap()</span><br><span class="line">  /*  24 */ uint64 epc;           // saved user program counter</span><br><span class="line">  /*  32 */ uint64 kernel_hartid; // saved kernel tp</span><br><span class="line"> ......</span><br><span class="line"> ......</span><br><span class="line"> .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>所以这条指令的作用是初始化Stack Pointer指向这个进程的kernel stack的最顶端。</strong></p><p>接下来的代码作用相似，从<code>trapframe page</code>当中取出<code>current hartid</code><em>(因为在RISC-V中，没有一个直接的方法来确认当前运行在多核处理器的哪个核上，XV6会将CPU核的编号也就是hartid保存在tp寄存器)<em>、<code>address of usertrap</code></em>(将要执行的第一个C函数的指针，也就是函数usertrap的指针。我们在后面会使用这个指针)</em></p><h4 id="2-5-ld-t1-0-a0-csrw-satp-t1-sfence-vma-zero-zero"><a href="#2-5-ld-t1-0-a0-csrw-satp-t1-sfence-vma-zero-zero" class="headerlink" title="2.5 ld t1, 0(a0);	csrw satp, t1;	sfence.vma zero, zero"></a>2.5 ld t1, 0(a0); csrw satp, t1; sfence.vma zero, zero</h4><p>第一行代码的作用是将kernel_satp 代码加载到t1寄存器</p><p>第二行代码的作用是将stap寄存器与t1寄存器的交换，<strong>当前程序会从user page table切换到kernel page table</strong></p><p>第三行代码的作用是，清除TLB缓存，当我们切换stap寄存器所存的值时，一般都需要清除TLB缓存。</p><h5 id="为什么代码没有崩溃？（来自于老师提问）"><a href="#为什么代码没有崩溃？（来自于老师提问）" class="headerlink" title="为什么代码没有崩溃？（来自于老师提问）"></a>为什么代码没有崩溃？（来自于老师提问）</h5><p>毕竟我们在内存中的某个位置执行代码，程序计数器保存的是虚拟地址，如果我们切换了page table，为什么同一个虚拟地址不会通过新的page table寻址走到一些无关的page中？看起来我们现在没有崩溃并且还在执行这些指令。</p><h6 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h6><p>trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。</p><p><strong>之所以叫trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。</strong></p><h4 id="2-6-jr-t0"><a href="#2-6-jr-t0" class="headerlink" title="2.6 jr t0"></a>2.6 jr t0</h4><p>t0寄存器的值在2.4中提到过，现在其中的值为<code>usertrap</code>函数的地址，通过这段代码我们跳转到了<code>usertrap</code>函数，进行接下来的操作。</p><h2 id="四、Usertrap函数"><a href="#四、Usertrap函数" class="headerlink" title="四、Usertrap函数"></a>四、Usertrap函数</h2><p>在<code>Uservec</code>函数的结尾，我们跳转到了Usertrap函数,所以程序现在运行usertrap函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  更改STVEC寄存器。取决于trap是来自于用户空间还是内核空间，实际上XV6处理trap的方法是不一样的。目前为止，我们只讨论过当trap是由用户空间发起时会发生什么。如果trap从内核空间发起，将会是一个非常不同的处理流程，因为从内核发起的话，程序已经在使用kernel page table。所以当trap发生时，程序执行仍然在内核的话，很多处理都不必存在</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取当前正在运行的进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  保存用户程序计数器，它仍然保存在SEPC寄存器中</span></span><br><span class="line"><span class="comment">  但是可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致SEPC寄存器的内容被覆盖。所以，我们需要保存当前进程的SEPC寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。这里我们使用trapframe来保存这个程序计数器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  <span class="comment">//根据触发trap的原因，RISC-V的SCAUSE寄存器会有不同的数字。数字8表明，我们现在在trap代码中是因为系统调用</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    XV6会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，我们需要显式的打开中断。（发生中断时，中断会关闭）</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    intr_on();</span><br><span class="line">	<span class="comment">//进入syscall函数</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>usertrap</code>函数中我们可以看到，倘若中断的原因是由<code>system call</code>引起的<code>（r_scause() == 8）</code>，那么程序将先执行<code>syscall（）</code>函数，再执行<code>usertrapret()</code>函数</p><h4 id="什么时候r-scause（）被设置"><a href="#什么时候r-scause（）被设置" class="headerlink" title="什么时候r_scause（）被设置"></a>什么时候<code>r_scause（）</code>被设置</h4><p>每个RISC-V CPU都有一组控制寄存器，内核通过向这些寄存器写入内容来告诉CPU如何处理陷阱，内核可以读取这些寄存器来明确已经发生的陷阱。</p><p>以下是最重要的一些寄存器概述：</p><ul><li><code>stvec</code>：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。</li><li><code>sepc</code>：当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li><li><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</li><li><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</li><li><code>sstatus</code>：其中的<strong>SIE</strong>位控制设备中断是否启用。如果内核清空<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核重新设置<strong>SIE</strong>。<strong>SPP</strong>位指示陷阱是来自用户模式还是管理模式，并控制<code>sret</code>返回的模式。</li></ul><p><strong>上述寄存器都用于在管理模式下处理陷阱，在用户模式下不能读取或写入。</strong>在机器模式下处理陷阱有一组等效的控制寄存器，xv6仅在计时器中断的特殊情况下使用它们。</p><p>多核芯片上的<strong>每个CPU都有自己的这些寄存器集</strong>，并且在任何给定时间都可能有多个CPU在处理陷阱。</p><p><strong>当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：</strong></p><ol><li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li><li>清除<strong>SIE</strong>以<strong>禁用中断</strong>。</li><li>将<code>pc</code>复制到<code>sepc</code>。</li><li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li><li>设置<code>scause</code>以反映产生陷阱的原因。</li><li>将模式设置为管理模式。</li><li>将<code>stvec</code>复制到<code>pc</code>。</li><li>在新的<code>pc</code>上开始执行。</li></ol><p><strong>综上所述，这是硬件进行的操作，所以我们在代码中看不见过程</strong></p><h2 id="五、Systemcall"><a href="#五、Systemcall" class="headerlink" title="五、Systemcall"></a>五、Systemcall</h2><p>在<code>usertrap</code>函数中我们进入了<code>systemcall</code>函数，在用户态执行<code>ecall</code>指令前，我们将<strong>系统调用号设置到了寄存器a7</strong>,执行ecall指令后，<code>uservec</code>函数将进程寄存器的所有值都被存入到了<code>trapframe</code>当中，所以我们通过<code>num = p-&gt;trapframe-&gt;a7;</code>取出系统调用号。</p><p><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code></p><p>这里向trapframe中的a0赋值的原因是：<strong>所有的系统调用都有一个返回值，比如write会返回实际写入的字节数，而RISC-V上的C代码的习惯是函数的返回值存储于寄存器a0，所以为了模拟函数的返回，我们将返回值存储在trapframe的a0中</strong>。之后，当我们返回到用户空间，trapframe中的a0槽位的数值会写到实际的a0寄存器，Shell会认为a0寄存器中的数值是write系统调用的返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/syscall.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>kernel/syscall.c</code>中，我们可以看出syscalls是一个<strong>函数指针数组</strong>，根据我们取出的系统调用号来调用不同的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们传入的系统调用号对应的是<code>SYS_sleep</code>,所以执行<code>sys_sleep</code>函数,函数定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：我们传入到内核的只有系统调用号，并没有其他途径告知内核传入参数的个数，所以我们自定义系统调用时，需要在用户态将函数声明中形参的个数与内核中系统调用函数中取参的个数相匹配，数目对不上编译器检查不出来错误。</strong></p><p><code>sys_sleep</code>函数利用<code>argint</code>函数取出应该休眠的时间<em>（若用户态为sleep(10),则n&#x3D;&#x3D;10）</em>，进行接下来的休眠操作。</p><h2 id="六、Usertrapret"><a href="#六、Usertrapret" class="headerlink" title="六、Usertrapret"></a>六、<code>Usertrapret</code></h2><p>在<code>Usertrap</code>函数中我们可以看出，系统调用执行完成后，我们应该执行<code>usertrapret</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  我们之前在系统调用的过程中是打开了中断的，这里关闭中断是因为我们将要更新STVEC寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码（6.6）。我们关闭中断因为当我们将STVEC更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即便我们现在仍然在内核中，出于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">STVEC寄存器指向trampoline代码，在那里最终会执行sret指令返回到用户空间。位于trampoline代码最后的sret指令会重新打开中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*填入了trapframe的内容，这些内容对于执行trampoline代码非常有用。这样下一次从用户空间转换到内核空间时可以用到这些数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  设置SSTATUS寄存器，这是一个控制寄存器。这个寄存器的SPP bit位控制了sret指令的行为，该bit为0表示下次执行sret的时候，我们想要返回user mode而不是supervisor mode。这个寄存器的SPIE bit位控制了，在执行完sret之后，是否打开中断。因为我们在返回到用户空间之后，我们的确希望打开中断，所以这里将SPIE bit位设置为1。修改完这些bit位之后，我们会把新的值写回到SSTATUS寄存器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">trampoline代码的最后执行了sret指令。这条指令会将程序计数器设置成SEPC寄存器的值，所以现在我们将SEPC寄存器的值设置成之前保存的用户程序计数器的值。在不久之前，我们在usertrap函数中将用户程序计数器保存在trapframe中的epc字段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">们根据user page table地址生成相应的SATP值，这样我们在返回到用户空间的时候才能完成page table的切换。实际上，我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中代码是同时在用户和内核空间中映射。但是我们现在还没有在trampoline代码中，我们现在还在一个普通的C函数中，所以这里我们将page table指针准备好，并将这个指针作为第二个参数传递给汇编代码，这个参数会出现在a1寄存器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  倒数第二行的作用是计算出我们将要跳转到汇编代码的地址。我们期望跳转的地址是tampoline中的userret函数，这个函数包含了所有能将我们带回到用户空间的指令。所以这里我们计算出了userret函数的地址</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  倒数第一行，将fn指针作为一个函数指针，执行相应的函数（也就是userret函数）并传入两个参数，两个参数存储在a0，a1寄存器中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、Userret"><a href="#七、Userret" class="headerlink" title="七、Userret"></a>七、<code>Userret</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        /*</span><br><span class="line">        在执行csrw satp, a1之前，page table应该还是巨大的kernel page table。这条指令会将user page table（在usertrapret中作为第二个参数传递给了这里的userret函数，所以存在a1寄存器中）存储在SATP寄存器中。执行完这条指令之后，page table就变成了小得多的user page table。但是幸运的是，user page table也映射了trampoline page，所以程序还能继续执行而不是崩溃</span><br><span class="line">        */</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        // 清空页表缓存</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        /*</span><br><span class="line">        将SSCRATCH寄存器恢复成保存好的用户的a0寄存器。在这里a0是trapframe的地址，因为C代码usertrapret函数中将trapframe地址作为第一个参数传递过来了。112是a0寄存器在trapframe中的位置</span><br><span class="line">        */</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line">		/*</span><br><span class="line">		之前保存的寄存器的值加载到对应的各个寄存器中</span><br><span class="line">		*/</span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line">        //a0寄存器现在还是个例外，它现在仍然是指向trapframe的指针，而不是保存了的用户数据。</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">        交换SSCRATCH寄存器和a0寄存器的值。前面我们看过了SSCRATCH现在的值是系统调用的返回值</span><br><span class="line">        */</span><br><span class="line">        # restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        /*</span><br><span class="line">        sret 的三个作用:</span><br><span class="line">        1.程序会切换回user mode</span><br><span class="line">        2.SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器） （usertrap中保存的）</span><br><span class="line">        3.重新打开中断（usertrapret中保存的）</span><br><span class="line">        */</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p><code>sret</code>最终返回到usermode，此时 **我们处于 系统调用 化身成为的三条汇编指令的最后一句：<code>ret</code>**，执行后回到调用<code>sleep</code>函数的地方</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>系统调用被刻意设计的看起来像是函数调用，但是背后的user&#x2F;kernel转换比函数调用要复杂的多。<strong>之所以这么复杂，很大一部分原因是要保持user&#x2F;kernel之间的隔离性，内核不能信任来自用户空间的任何内容。</strong></p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>MIT6.S081中Systemcall的调用流程</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.shui2000.top/posts/932c8df1.html">https://www.shui2000.top/posts/932c8df1.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>水更流</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-04-22</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-04-29</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MIT6-S081/">MIT6.S081</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/Systemcall/">Systemcall</a></div><div class="post_share"><div class="social-share" data-image="https://pic.shui2000.top/img/wallpaper-106.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload='this.media="all"'><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4fd45b61.html" title="MIT6.S081_2020_Lab5:LazyPageAllocation"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-28.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MIT6.S081_2020_Lab5:LazyPageAllocation</div></div></a></div><div class="next-post pull-right"><a href="/posts/c808110f.html" title="MIT6.S081_2020_Lab3:page tables"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-84.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MIT6.S081_2020_Lab3:page tables</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/c808110f.html" title="MIT6.S081_2020_Lab3:page tables"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-84.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-20</div><div class="title">MIT6.S081_2020_Lab3:page tables</div></div></a></div><div><a href="/posts/4fd45b61.html" title="MIT6.S081_2020_Lab5:LazyPageAllocation"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-28.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-07</div><div class="title">MIT6.S081_2020_Lab5:LazyPageAllocation</div></div></a></div><div><a href="/posts/e18dbd36.html" title="MIT6.S081_2020_Lab6:Copy-on-Write"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-59.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-07</div><div class="title">MIT6.S081_2020_Lab6:Copy-on-Write</div></div></a></div><div><a href="/posts/a33744ac.html" title="MIT6.S081_2020_Lab6:init-starting-sh-bug-原因分析"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-49.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-07</div><div class="title">MIT6.S081_2020_Lab6:init-starting-sh-bug-原因分析</div></div></a></div><div><a href="/posts/8a8374bd.html" title="MIT6.S081 Operating System Engineering介绍"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-58.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-19</div><div class="title">MIT6.S081 Operating System Engineering介绍</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar1.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">水更流</div><div class="author-info__description">Talk is cheap,Show me the code!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/0shuigengliu"><i></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/0shuigengliu" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:yuanfan0207@qq.com" target="_blank" title="Main"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-17"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-tongzhi"></use></svg></a><span>公告</span></div><div class="announcement_content">这是一个公告栏</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%88-x2F-user-x2F-%EF%BC%89%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">一、用户态（&#x2F;user&#x2F;）中的系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%94%9F%E6%88%90%E7%9A%84usys-S%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">二、生成的usys.S文件中的汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-li-a7-SYS-sleep"><span class="toc-number">3.1.</span> <span class="toc-text">1.li a7, SYS_sleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ecall%EF%BC%88%E8%AF%A5%E6%8C%87%E4%BB%A4%E4%B8%BACPU%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2.ecall（该指令为CPU指令）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-ecall%E5%B0%86%E4%BB%A3%E7%A0%81%E4%BB%8Euser-mode%E6%94%B9%E5%88%B0supervisor-mode"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 ecall将代码从user mode改到supervisor mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-ecall%E5%B0%86%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%80%BC%E4%BF%9D%E5%AD%98%E5%9C%A8%E4%BA%86SEPC%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 ecall将程序计数器的值保存在了SEPC寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-ecall%E4%BC%9A%E8%B7%B3%E8%BD%AC%E5%88%B0STVEC%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E5%90%91%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%88uservec%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 ecall会跳转到STVEC寄存器指向的指令（uservec函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1%E4%B8%BA%E4%BB%80%E4%B9%88ecall%E6%8C%87%E4%BB%A4%E5%9C%A8xv6%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E5%BE%88%E5%B0%91%EF%BC%9F%EF%BC%88%E6%91%98%E6%8A%84%E8%87%AA%E8%AF%BE%E7%A8%8B%E7%BF%BB%E8%AF%91%EF%BC%89"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">2.3.1为什么ecall指令在xv6做的事情很少？（摘抄自课程翻译）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%9C%A8gdb%E4%B8%AD%E7%9C%8B%E4%B8%8D%E5%88%B0ecall%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%EF%BC%9F%EF%BC%88%E8%AF%BE%E5%A0%82%E5%AD%A6%E7%94%9F%E6%8F%90%E9%97%AE%EF%BC%89"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2.3.2 为什么我们在gdb中看不到ecall的具体内容？（课堂学生提问）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ret"><span class="toc-number">3.3.</span> <span class="toc-text">3.ret</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81trampoline-page"><span class="toc-number">4.</span> <span class="toc-text">三、trampoline page</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-trampoline-%E6%98%A0%E5%B0%84%E6%97%B6%E7%9A%84%E7%89%B9%E5%88%AB%E4%B9%8B%E5%A4%84"><span class="toc-number">4.1.</span> <span class="toc-text">1.trampoline 映射时的特别之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Uservec%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">2.Uservec函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-csrrw-a0-sscratch-a0"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 csrrw a0, sscratch, a0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%BD%93%E4%B8%8Ea0%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E4%BA%A4%E6%8D%A2%E6%97%B6%EF%BC%8Ctrapframe%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E6%80%8E%E4%B9%88%E5%87%BA%E7%8E%B0%E5%9C%A8SSCRATCH%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">问题：当与a0寄存器进行交换时，trapframe的地址是怎么出现在SSCRATCH寄存器中的？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8F%90%E9%97%AE%EF%BC%9A%E8%BF%99%E6%98%AF%E5%8F%91%E7%94%9F%E5%9C%A8%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%90%97%EF%BC%9F%E8%BF%99%E4%B8%AASSCRATCH%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%9C%A8%E4%BA%8E%E5%93%AA%EF%BC%9F"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text">深入提问：这是发生在进程创建的过程中吗？这个SSCRATCH寄存器存在于哪？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#a0%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%80%BC%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.1.1.2.</span> <span class="toc-text">a0寄存器中的值是怎么来的？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E4%BD%A0%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%B9%8B%E5%90%8E%E8%BF%9B%E7%A8%8B%E5%9C%A8%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%9C%A8%E6%9F%90%E4%B8%AA%E6%97%B6%E9%97%B4%E7%82%B9%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BA%86ecall%E6%8C%87%E4%BB%A4%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%A0%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84fn%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F%E5%9B%A0%E4%B8%BA%E8%BF%99%E6%98%AF%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAecall%E6%8C%87%E4%BB%A4%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B9%8B%E5%89%8D%E5%BA%94%E8%AF%A5%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E8%BF%87fn%E5%87%BD%E6%95%B0%E5%90%A7%EF%BC%9F%EF%BC%88%E5%AD%A6%E7%94%9F%E6%8F%90%E9%97%AE%EF%BC%89"><span class="toc-number">4.2.1.1.3.</span> <span class="toc-text">当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了ecall指令，那么你是在什么时候执行上一个问题中的fn函数呢？因为这是进程的第一个ecall指令，所以这个进程之前应该没有调用过fn函数吧？（学生提问）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-sd-ra-40-a0"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 sd ra, 40(a0)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%9D%E5%AD%98%E5%9C%A8%E4%BA%86trapframe-page%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%BA%9B%E5%AF%84%E5%AD%98%E5%99%A8%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E4%B9%9F%E8%83%BD%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%88%E6%8C%87%E7%9A%84%E6%98%AFtrapframe-page%EF%BC%89%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BD%BF%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A0%88"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">问题 寄存器保存在了trapframe page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe page），而不是使用程序的栈?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-csrr-t0-sscratch-sd-t0-112-a0"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 csrr t0, sscratch ;sd t0, 112(a0)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-ld-sp-8-a0"><span class="toc-number">4.2.4.</span> <span class="toc-text">2.4 ld sp, 8(a0)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-ld-t1-0-a0-csrw-satp-t1-sfence-vma-zero-zero"><span class="toc-number">4.2.5.</span> <span class="toc-text">2.5 ld t1, 0(a0); csrw satp, t1; sfence.vma zero, zero</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E5%B4%A9%E6%BA%83%EF%BC%9F%EF%BC%88%E6%9D%A5%E8%87%AA%E4%BA%8E%E8%80%81%E5%B8%88%E6%8F%90%E9%97%AE%EF%BC%89"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">为什么代码没有崩溃？（来自于老师提问）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AD%94%E6%A1%88"><span class="toc-number">4.2.5.1.1.</span> <span class="toc-text">答案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-jr-t0"><span class="toc-number">4.2.6.</span> <span class="toc-text">2.6 jr t0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Usertrap%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">四、Usertrap函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99r-scause%EF%BC%88%EF%BC%89%E8%A2%AB%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.0.1.</span> <span class="toc-text">什么时候r_scause（）被设置</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Systemcall"><span class="toc-number">6.</span> <span class="toc-text">五、Systemcall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Usertrapret"><span class="toc-number">7.</span> <span class="toc-text">六、Usertrapret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Userret"><span class="toc-number">8.</span> <span class="toc-text">七、Userret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">八、总结</span></a></li></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"><span id="percent">0<span>%</span></span></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.shuigengliu.top/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.shuigengliu.top/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}' title='${e[n].content}'>${e[n].content}</a>\n        <div class='name'><span>${e[n].nick} / </span><time datetime="${e[n].date}">${btf.diffDate(e[n].date,!0)}</time></div>\n        </div></div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n.innerHTML=t,window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.shuigengliu.top/",region:"",pageSize:6,includeReply:!0}).then((function(t){const n=t.map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t}));saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),10/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").innerHTML="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)}))</script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="https://pic.shui2000.top/source/js/menuiconfont.js"></script><script async src="https://pic.shui2000.top/source/js/iconfont.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><div class="aplayer no-destroy" data-id="7341248648" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-order="random" data-preload="auto"></div><script defer src="https://pic.shui2000.top/source/js/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script defer data-pjax src="/js/emoji.js"></script><script async src="https://pic.shui2000.top/source/js/vue.min.js"></script><script async src="https://pic.shui2000.top/source/js/index.js"></script><script src="https://pic.shui2000.top/source/js/clipboard.min.js"></script><script src="/js/share.js"></script><script src="https://pic.shui2000.top/source/js/echarts.min.js"></script><script defer data-pjax src="/js/CountbyEurkon.js"></script><script defer data-pjax src="/js/f12.js"></script><script defer src="https://pic.shui2000.top/source/js/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script src="/js/sun_moon.js" async></script><script src="https://pic.shui2000.top/source/js/rightmenu.js"></script><script src="/js/rightmenu.js"></script><script async src="https://pic.shui2000.top/source/js/sakura.js"></script><script defer src="/js/sakura.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a></div></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.shui2000.top/categories/项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎒 实操项目 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.shui2000.top/categories/瞎折腾/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">‍👓 折腾NAS等硬件 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.shui2000.top/categories/BUG大全/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 学习中遇到的BUG以及解决方法 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.shui2000.top/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 算法学习 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.shui2000.top/categories/笔记转载/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🧑‍💻 留存学习过程中，看见他人的笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://www.shui2000.top/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var a=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),a&&a.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="/",qweather_key="7326296787ac4230ae8a0892ad57426a",gaud_map_key="347858c37c888ccfcc2dc76895facff2",baidu_ak_key="undefined",flag=0,clock_rectangle="113.34532,23.15624",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://pic.shui2000.top/source/js/he-simple-common.js"></script><script data-pjax src="https://pic.shui2000.top/source/js/clock.min.js"></script><script data-pjax>function butterfly_footer_beautify_injector_config(){var A=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),A.insertAdjacentHTML("beforeend",'<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署,主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署,备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),a.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f1a64171.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-108.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-02-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f1a64171.html&quot;);" href="javascript:void(0);" alt="">二叉树的前中后三序遍历</a><div class="blog-slider__text">递归与非递归两种方式实现二叉树的前中后三序遍历</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f1a64171.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/626b2962.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/Uomi_AI3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-08</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/626b2962.html&quot;);" href="javascript:void(0);" alt="">群晖的基础玩法</a><div class="blog-slider__text">本篇文章主要介绍了群晖的基础玩法</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/626b2962.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a33744ac.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-49.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-06-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a33744ac.html&quot;);" href="javascript:void(0);" alt="">MIT6.S081_2020_Lab6:init-starting-sh-bug-原因分析</a><div class="blog-slider__text">分析lab6实验中出现的bug</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a33744ac.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e18dbd36.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-59.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-06-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e18dbd36.html&quot;);" href="javascript:void(0);" alt="">MIT6.S081_2020_Lab6:Copy-on-Write</a><div class="blog-slider__text">为XV6增加copy on write机制</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e18dbd36.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4fd45b61.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-28.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-05-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4fd45b61.html&quot;);" href="javascript:void(0);" alt="">MIT6.S081_2020_Lab5:LazyPageAllocation</a><div class="blog-slider__text">将xv6系统的eager allocation 修改为 lazy allocation</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4fd45b61.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/932c8df1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-106.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/932c8df1.html&quot;);" href="javascript:void(0);" alt="">MIT6.S081中Systemcall的调用流程</a><div class="blog-slider__text">总结了MIT6.S081中Systemcall调用的流程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/932c8df1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c808110f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-84.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c808110f.html&quot;);" href="javascript:void(0);" alt="">MIT6.S081_2020_Lab3:page tables</a><div class="blog-slider__text">项目MIT6.S081的笔记,本来想把MIT6.S081的每个lab都做一个总结，后来发现单单做一个lab3就已经很费力气，后续打算只将较难的实验总结出来</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c808110f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8a8374bd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.shui2000.top/img/wallpaper-58.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8a8374bd.html&quot;);" href="javascript:void(0);" alt="">MIT6.S081 Operating System Engineering介绍</a><div class="blog-slider__text">项目MIT6.S081的笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8a8374bd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://pic.shui2000.top/source/js/swiper.min.js"></script><script defer data-pjax src="https://pic.shui2000.top/source/js/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","1s"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","2")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://pic.shui2000.top/source/js/wow.min.js"></script><script defer src="https://pic.shui2000.top/source/js/wow_init.js"></script></body></html>